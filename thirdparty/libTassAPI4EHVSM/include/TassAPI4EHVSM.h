/**
* Copyright (C) 2021 TASS
* @file TassAPI4EHVSM.h
* @brief 金融机的指令集合
* @details Refer to the header file to pass instructions
* @author Kangying
* @version 2.0.0
* @date 2021/09/02
* Change History :
* <Date>     | <Version>  | <Author>       | <Description>
*---------------------------------------------------------------------------
* 2021/09/02 | 2.0.0      | Kangying       | Create file
*---------------------------------------------------------------------------
*/

#ifndef TASSAPIFRAME_TASSAPI4EHVSM_H
#define TASSAPIFRAME_TASSAPI4EHVSM_H

#ifdef  __cplusplus
extern "C" {
#endif

#include "frmTypes.h"

#if _MSC_VER  //_MSC_VER是微软的预编译控制。
#define STDCALL_ __stdcall
#else
#define STDCALL_
	//stdcall的调用约定意味着：1）参数从右向左压入堆栈，2）函数自身修改堆栈 3)函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸。
#endif


   /*
	后缀定义
	_G:general通用
	_C:compatibility兼容
	*/
	/**
	*@brief 加密机支持的对称算法
	*=============================
	*|标识|  缩写  |含义         |
	*|----+--------+-------------|
	*|----+--------+-------------|
	*| X  |  DES2  |双倍长DES    |
	*|----+--------+-------------|
	*| U  |DES2-VAR|双倍长DES变种|
	*|----+--------+-------------|
	*| Y  |  DES3  |三倍长DES    |
	*|----+--------+-------------|
	*| T  |DES3-VAR|三倍长DES变种|
	*|----+--------+-------------|
	*| P  |  SM1   |SM1          |
	*|----+--------+-------------|
	*| R  |  SM4   |SM4          |
	*|----+--------+-------------|
	*| L  | AES128 |AES128       |
	*|----+--------+-------------|
	*| M  | AES192 |AES192       |
	*|----+--------+-------------|
	*| N  | AES256 |AES256       |
	*=============================
	*/
	/**
	*@brief 加密机支持的密钥类型
	*===================================
	*|代码|   缩写    |代码|   缩写    |
	*|----+-----------|----+-----------|
	*|000 |  ZMK/KEK  |001 |    ZPK    |
	*|----+-----------|----+-----------|
	*|002 |PVK/TPK/TMK|003 |    TAK    |
	*|----+-----------|----+-----------|
	*|007 |    EDK    |008 |    ZAK    |
	*|----+-----------|----+-----------|
	*|009 |    BDK    |00A |  DEK/ZEK  |
	*|----+-----------|----+-----------|
	*|00B |    TEK    |011 |    KMC    |
	*|----+-----------|----+-----------|
	*|109 | MK-AC/MDK |10C |   HMAC    |
	*|----+-----------|----+-----------|
	*|209 |  MK-SMI   |309 |  MK-SMC   |
	*|----+-----------|----+-----------|
	*|402 |    CVK    |409 |  MK-DAK   |
	*|----+-----------|----+-----------|
	*|509 |   MK-DN   |    |           |
	*===================================
	*/
	/**
	*@brief 加密机支持的填充模式
	*===========================================================================
	*|代码|                               含义                                 |
	*|----+--------------------------------------------------------------------|
	*|    |遵循PBOC2.0加解密数据填充规范.                                      |
	*|    |若输入数据MSG的长度是分组长度N的整数倍,则不填充;                    |
	*| 0  |否则,在MSG的右端加上一个字节0x80,然后在右边加上最少的0x00,          |
	*|    |使得MSG'=(MSG||'80'||'00'||…||'00')的长度满足N的整数倍.            |
	*|    |注:若原始数据的最末字节可能是0x80,则加解密运算不建议使用此模式.     |
	*|----+--------------------------------------------------------------------|
	*|    |遵循ISO/IEC9797-1的PADDING模式2标准;等同PBOC2.0MAC运算数据填充规范. |
	*| 1  |在输入数据MSG的右端强制加上一个字节的0x80,然后在右边加上最少的0x00, |
	*|    |使得MSG'=(MSG||'80'||'00'||…||'00')的长度满足N的整数倍.            |
	*|----+--------------------------------------------------------------------|
	*|    |遵循ISO/IEC9797-1的PADDING模式1标准;                                |
	*|    |等同ANSIX9.19规范;符合银联规范应用中MAC运算填充模式.                |
	*| 2  |若输入数据MSG的长度是分组长度N的整数倍,则不填充;                    |
	*|    |否则,在MSG的右端加上最少的0x00,                                     |
	*|    |使MSG'=(MSG||'00'||…||'00')长度满足N的整数倍.                      |
	*|    |注:若原始数据的最末字节可能是0x00,则加解密运算不建议使用此模式      |
	*|----+--------------------------------------------------------------------|
	*|    |遵循ANSI X9.23中定义的规范.                                         |
	*| 3  |在输入数据MSG的右端强制添加最少的0x00,且最后一个字节添加PAD的字节数,|
	*|    |使MSG'=(MSG||'00'||…||'XX')的长度满足N的整数倍,XX取值为0x01-0x10.  |
	*|----+--------------------------------------------------------------------|
	*|    |遵循PKCS#5中定义的规范.                                             |
	*| 4  |在输入数据MSG的右端强制添加N-(MSGLEN%N)个0x(N-(MSGLEN%N)),          |
	*|    |其中N为分组长度,即对MSG,分组后最右端数据块缺m个字节则补充m个数值m,  |
	*|    |最少补1个0x01,最多补16个0x10(当MSGLEN为N(16字节分组)的整数倍时).    |
	*|----+--------------------------------------------------------------------|
	*| 5  |密码机不填充,外部应用将数据填充到加密算法的分组长度N的整数倍.       |
	*|----+--------------------------------------------------------------------|
	*|    |PBOC3.0规范的加解密数据填充模式.                                    |
	*| 10 |在输入数据MSG左端填充1-3个字节的数据长度(ASN.1编码对象的长度域),    |
	*|    |然后对填充长度域的MSG'进行类同模式0的填充.                          |
	*|----+--------------------------------------------------------------------|
	*| 11 |在输入数据MSG左端填充1-3个字节的数据长度(ASN.1编码对象的长度域),    |
	*|    |然后对填充长度域的MSG'进行类同模式1的填充.                          |
	*===========================================================================
	*/
	/**
	*@brief 加密机支持的分散模式
	*=======================================================================
	*|代码|                               含义                             |
	*|----+----------------------------------------------------------------|
	*| 0  |PBOC子密钥分散算法,8字节分散因子D,ECB模式加密16字节[D||~D].     |
	*|----+----------------------------------------------------------------|
	*| 1  |ECB模式加密16字节分散因子.                                      |
	*|----+----------------------------------------------------------------|
	*| 2  |ECB模式加密16字节分散因子,并复制扩展为32字节长度密钥(子密钥为N).|
	*|----+----------------------------------------------------------------|
	*| 3  |CBC模式加密16字节分散因子.                                      |
	*|----+----------------------------------------------------------------|
	*| 4  |ECB模式加密分散因子,分散因子必须为8字节的倍数,且至少16字节,     |
	*|    |取加密结果的前后各8字节作为子密钥(子密钥为X/U).                 |
	*|----+----------------------------------------------------------------|
	*| 5  |CBC模式加密分散因子,分散因子必须为16字节的倍数,                 |
	*|    |取加密结果的最后16字节作为子密钥(子密钥为L).                    |
	*=======================================================================
	*/
	/**
	*@brief 加密机支持的MAC算法模式
	*==============================================================================
	*|代码|                               含义                                    |
	*|----+-----------------------------------------------------------------------|
	*| 01 |ISO9797-1 MAC算法模式1,MAC密钥CBC模式加密数据,取最后一段密文.          |
	*|----+-----------------------------------------------------------------------|
	*| 03 |ISO9797-1 MAC算法模式3,限密钥标识为X/U.等同于ANSI X9.19,MAC密钥16字节, |
	*|    |KL首先CBC加密数据,然后KR解密最后一段结果,最后KL加密解密结果,得8字节MAC.|
	*==============================================================================
	*/
	/**
	*@brief 加密机MAC取值方式
	*=====================================
	*|代码 |            含义             |
	*|-----+-----------------------------|
	*|01-08|输出MAC值的左n字节           |
	*|-----+-----------------------------|
	*|11-18|输出MAC值的右n字节           |
	*|-----+-----------------------------|
	*|21-28|左右异或后取左n字节输出      |
	*|-----+-----------------------------|
	*|31-38|左右异或后取右n字节输出      |
	*|-----+-----------------------------|
	*| 44  |四字节异或,最后输出4字节     |
	*|-----+-----------------------------|
	*| 10  |全16字节MAC,(限密钥为P/L/R时)|
	*=====================================
	*/
	/**
	*@brief 会话密钥的产生模式
	*=================================================================
	*|代码|                        含义                              |
	*|----+----------------------------------------------------------|
	*| 00 |不产生会话密钥.                                           |
	*|----+----------------------------------------------------------|
	*| 01 |ECB模式加密8字节会话密钥因子(一般为[6字节0x00||2字节ATC]),|
	*|    |得8字节会话密钥,仅限源密钥为X/U算法类型.                  |
	*|----+----------------------------------------------------------|
	*| 02 |ECB模式加密16字节会话密钥因子(一般为[6字节0x00||2字节ATC|||
	*|    |6字节0x00+2字节~ATC]),得16字节会话密钥.                   |
	*|----+----------------------------------------------------------|
	*| 03 |密钥的左右8字节异或,得8字节会话密钥,                      |
	*|    |仅限源密钥为X/U算法类型.                                  |
	*|----+----------------------------------------------------------|
	*| 04 |取密钥的左8字节做为会话密钥.                              |
	*|----+----------------------------------------------------------|
	*|    |CBC模式加密16字节会话密钥因子(一般为[2字节密钥类型||2字节 |
	*|    |卡计数器||12 字节0x00]),得16字节会话密钥.                 |
	*| 05 |一般用于由Kenc/Kmac/Kdek分散产生卡片与主机间安全通道的会话|
	*|    |密钥,其中2字节密钥类型为:                                 |
	*|    |Senc:'0182';Scmac:'0101';Srmac:'0102';Sdek:'0181'.        |
	*=================================================================
	*/
	/**
	*@brief 加密机支持的摘要算法
	*=================================
	*|代码|   含义   |代码|   含义   |
	*|----+----------|----+----------|
	*| 03 |ISO10118-2| 05 |SHA-224   |
	*|----+----------|----+----------|
	*| 06 |SHA-256   | 07 |SHA-384   |
	*|----+----------|----+----------|
	*| 08 |SHA-512   | 20 |SM3-256   |
	*=================================
	*/
	/**
	*@brief 加密机支持的PINBLOCK(数字)格式
	*====================================================================================
	*|代码|                                    含义                                     |
	*|----+-----------------------------------------------------------------------------|
	*|    |ANSI X9.8格式,等同ISO9564-1格式0,也是银联规范应用中带主账号信息的格式.       |
	*|    |1)PIN明文按照0x0N||PIN||0xFF…0xFF格式处理,其中N为PIN的位数,0xFF为填充字符,  |
	*|    |  填充到分组长度(8或16字节);                                                 |
	*|    |2)取账号最右侧去除1位校验位后的12位(6字节),左侧填充0x00到分组长度(8或16字节);|
	*|    |3)将以上两个分组长度的数据块异或即为PINBLOCK.                                |
	*|    |例:5位PIN明文92389,12位帐号400000123456;                                     |
	*|    |   1)PIN填充:                                                                |
	*| 01 |       8字节分组:0x0592389FFFFFFFFF,                                         |
	*|    |       16字节分组:0x0592389FFFFFFFFFFFFFFFFFFFFFFFFF;                        |
	*|    |   2)账号填充:                                                               |
	*|    |       8字节分组:0x0000400000123456,                                         |
	*|    |       16字节分组:0x00000000000000000000400000123456;                        |
	*|    |   3)两部分异或:                                                             |
	*|    |       8字节分组:0x0592789FFFEDCBA9,                                         |
	*|    |       16字节分组:0x0592389FFFFFFFFFFFFFBFFFFFEDCBA9.                        |
	*|----+-----------------------------------------------------------------------------|
	*|    |支持Docutel ATMs应用,PIN长度限制4-6.无需账号信息,如PIN少于6位,则右边填充0.   |
	*|    |PINBLOCK数据块格式为[1位PIN长度||6位PIN||自定义数字填充串].                  |
	*| 02 |例:5位PIN明文92389;                                                          |
	*|    |   8字节分组:0x5923890987654321,                                             |
	*|    |   16字节分组:0x59238909876543218765432187654321.                            |
	*|----+-----------------------------------------------------------------------------|
	*|    |支持Diebold和IBM ATMs应用.也可应用在不含PIN长度的Docutel格式.                |
	*|    |PIN块由客户PIN和填充字符'F'组成.                                             |
	*| 03 |例:5位PIN明文92389;                                                          |
	*|    |   8字节分组:0x92389FFFFFFFFFFF,                                             |
	*|    |   16字节分组:0x92389FFFFFFFFFFFFFFFFFFFFFFFFFFF.                            |
	*|----+-----------------------------------------------------------------------------|
	*|    |PLUS网络采用的PIN块格式.                                                     |
	*|    |1)PIN明文按照0x0N||PIN||0xFF…0xFF格式处理,其中N为PIN的位数,0xFF为填充字符,  |
	*|    |  填充到分组长度(8或16字节);                                                 |
	*|    |2)取账号最左侧12位(6字节),然后左侧填充0x00到分组长度(8或16字节);             |
	*|    |3)将以上两个分组长度的数据块异或即为PINBLOCK.                                |
	*|    |例:5位PIN明文92389,12位帐号228340000012;                                     |
	*|    |   1)PIN填充:                                                                |
	*|    |       8字节分组:0x0592389FFFFFFFFF,                                         |
	*|    |       16字节分组:0x0592389FFFFFFFFFFFFFFFFFFFFFFFFF;                        |
	*| 04 |   2)账号填充:                                                               |
	*|    |       8字节分组:0x0000228340000012,                                         |
	*|    |       16字节分组:0x00000000000000000000228340000012;                        |
	*|    |   3)两部分异或:                                                             |
	*|    |       8字节分组:0x05921A1CBFFFFFED,                                         |
	*|    |       16字节分组:0x0592389FFFFFFFFFFFFFDD7CBFFFFFED.                        |
	*|    |注:当PIN块采用格式04时,它的帐号域长度必须为18位.                             |
	*|    |   对PIN转换CA和CC命令,存在两个格式域.如果任一个为格式04,则该帐号域必须为18位|
	*|    |   若该帐号域少于18个数字,则必须右对齐并左填充'F'至18位.                     |
	*|    |   命令BC,BE,CA,CC,CG,DA,DC,EA,EC,EG,JC,JE可使用格式04:.当使用这些命令时,应考|
	*|    |   虑对应该格式时相应帐号域需做的改变,即出现格式04,则帐号域由12位变为18位.   |
	*|----+-----------------------------------------------------------------------------|
	*|    |ISO9564-1格式1.                                                              |
	*|    |由以下十六进制数值表示的PIN格式:1N||P1…PN||R…R,                            |
	*|    |其中N为PIN的长度(4-C),P1…PN为N个数字的PIN,R…R为随机填充数,填充至分组长度,  |
	*|    |当输入PIN格式为格式05时必须执行以下有效性校验:                               |
  *|    |PIN块第一个字符必须为值1,否则返回错误码20;                                   |
  *| 05 |PIN块第二个字符(N)取值范围必须为十六进制数4-C,否则返回错误码24;              |
  *|    |PIN数字(位置3-(N+2))取值范围必须为0-9,否则返回错误码20.                      |
	*|    |例:5位PIN明文92389;                                                          |
	*|    |   PIN填充:                                                                  |
	*|    |     8字节分组:0x1592389123456789,                                           |
	*|    |     16字节分组:0x15923891234567890123456789012345.                          |
	*|----+-----------------------------------------------------------------------------|
	*|    |ISO9564-1格式2,等同于格式34.                                                 |
	*|    |由以下十六进制数值表示的PIN格式:2N||P1…PN||F…F,                            |
	*|    |其中N为PIN的长度(4-C),P1…PN为N个数字的PIN,F…F为填充数,填充至分组长度,      |
	*|    |当输入PIN格式为格式06时必须执行以下有效性校验:                               |
  *|    |PIN块第一个字符必须为值2,否则返回错误码20;                                   |
  *| 06 |PIN块第二个字符(N)取值范围必须为十六进制数4-C,否则返回错误码24;              |
  *|    |PIN数字(位置3-(N+2))取值范围必须为0-9,否则返回错误码20.                      |
	*|    |例:5位PIN明文92389;                                                          |
	*|    |   PIN填充:                                                                  |
	*|    |     8字节分组:0x2592389FFFFFFFFF,                                           |
	*|    |     16字节分组:0x2592389FFFFFFFFFFFFFFFFFFFFFFFFF;                          |
	*|----+-----------------------------------------------------------------------------|
	*|    |银联规范应用中不带主账号信息的PIN格式,支持8字节和16字节分组算法.             |
	*|    |由以下十六进制数值表示的PIN格式:0N||P1…PN||F…F,                            |
	*|    |其中N为PIN的长度(4-C),P1…PN为N个数字的PIN,F…F为填充数,填充至分组长度,      |
	*|    |当输入PIN格式为格式07时必须执行以下有效性校验:                               |
  *|    |PIN块第一个字符必须为值0,否则返回错误码20;                                   |
  *| 07 |PIN块第二个字符(N)取值范围必须为十六进制数4-C,否则返回错误码24;              |
  *|    |PIN数字(位置3-(N+2))取值范围必须为0-9,否则返回错误码20.                      |
	*|    |例:5位PIN明文92389;                                                          |
	*|    |   PIN填充:                                                                  |
	*|    |     8字节分组:0x0592389FFFFFFFFF,                                           |
	*|    |     16字节分组:0x0592389FFFFFFFFFFFFFFFFFFFFFFFFF;                          |
	*|----+-----------------------------------------------------------------------------|
	*|    |扩展的ANSIX9.8格式.                                                          |
	*|    |采用8字节分组算法加密时,与格式01相同.                                        |
	*|    |采用16字节分组算法加密时,PIN明文处理与格式01相同,但账号处理如下:取账号最右侧 |
	*|    |去除1位校验位后的12位(6字节),左侧填充0x00到8字节,然后在右侧填充0x00至16字节. |
	*|    |例:5位PIN明文92389,12位帐号400000123456;                                     |
	*|    |   1)PIN填充:                                                                |
	*| 11 |       8字节分组:0x0592389FFFFFFFFF,                                         |
	*|    |       16字节分组:0x0592389FFFFFFFFFFFFFFFFFFFFFFFFF;                        |
	*|    |   2)账号填充:                                                               |
	*|    |       8字节分组:0x0000400000123456,                                         |
	*|    |       16字节分组:0x00004000001234560000000000000000;                        |
	*|    |   3)两部分异或:                                                             |
	*|    |       8字节分组:0x0592789FFFEDCBA9,                                         |
	*|    |       16字节分组:0x0592789FFFEDCBA9FFFFBFFFFFEFFFFF.                        |
	*|----+-----------------------------------------------------------------------------|
	*| 34 |EMV PIN数据块格式,等同于ISO9564-1格式2(格式06).                              |
	*|----+-----------------------------------------------------------------------------|
	*|    |Europay/MasterCard for their Pay Now & Pay Later products应用的PIN数据块格式 |
	*|    |处理方法基本与格式01相同但第1)步PIN明文处理中0x0N||PIN||0xFF…0xFF格式修改为 |
	*|    |0x2N||PIN||0xFF…0xFF格式处理,其余处理与格式01完全相同.                      |
	*|    |例:5位PIN明文92389,12位帐号400000123456;                                     |
	*|    |   1)PIN填充:                                                                |
	*|    |       8字节分组:0x2592389FFFFFFFFF,                                         |
	*| 35 |       16字节分组:0x2592389FFFFFFFFFFFFFFFFFFFFFFFFF;                        |
	*|    |   2)账号填充:                                                               |
	*|    |       8字节分组:0x0000400000123456,                                         |
	*|    |       16字节分组:0x00000000000000000000400000123456;                        |
	*|    |   3)两部分异或:                                                             |
	*|    |       8字节分组:0x2592789FFFEDCBA9,                                         |
	*|    |       16字节分组:0x2592389FFFFFFFFFFFFFBFFFFFEDCBA9.                        |
	*|----+-----------------------------------------------------------------------------|
	*|    |VISA/PBOC不使用当前PIN进行PIN修改的格式.                                     |
	*|    |使用新PIN和唯一DEA密钥的部分生成PIN块:                                       |
	*|    |1)提取卡应用唯一DEA密钥A(UDK-A,即MK-AC的卡片子密钥的左半部分)的最右8位(4字节)|
	*|    |  并在左侧填充0x00至8字节;                                                   |
	*|    |2)PIN明文按照0x0N||PIN||0xFF…0xFF格式处理,其中N为PIN的位数,0xFF为填充字符,  |
	*| 41 |  填充到8字节;                                                               |
	*|    |3)将以上两个8字节数据块异或即为PINBLOCK.                                     |
	*|    |例:MK-AC的卡片子密钥:9726E0803B070497 57D0299BDA7CF42F,5位PIN明文92389;      |
	*|    |   1)密钥相关数据段为:0x000000003B070497;                                    |
	*|    |   2)PIN填充:0x0592389FFFFFFFFF;                                             |
	*|    |   3)两部分异或:0x0592389FC4F8FB68.                                          |
	*|----+-----------------------------------------------------------------------------|
	*|    |VISA/PBOC使用当前PIN进行PIN修改的格式.                                       |
	*|    |使用当前PIN、新PIN和唯一DEA密钥的部分生成PIN块:                              |
	*|    |1)提取卡应用唯一DEA密钥A(UDK-A,即MK-AC的卡片子密钥的左半部分)的最右8位(4字节)|
	*|    |  并在左侧填充0x00至8字节;                                                   |
	*|    |2)新PIN明文按照0x0N||PIN||0xFF…0xFF格式处理,其中N为PIN的位数,0xFF为填充字符,|
	*|    |  填充到8字节;                                                               |
	*| 42 |3)当前PIN填充若干0至8字节;                                                   |
	*|    |4)将以上三个个8字节数据块异或即为PINBLOCK.                                   |
	*|    |例:MK-AC的卡片子密钥:9726E0803B070497 57D0299BDA7CF42F,5位新PIN明文92389,6位 |
	*|    |   当前PIN明文111111;                                                        |
	*|    |   1)密钥相关数据段为:0x000000003B070497;                                    |
	*|    |   2)新PIN填充:0x0592389FFFFFFFFF;                                           |
	*|    |   3)当前PIN填充:0x1111110000000000;                                         |
	*|    |   3)三部分异或:0x1483299FC4F8FB68.                                          |
	*|----+-----------------------------------------------------------------------------|
	*|    |ISO9564-1格式3.                                                              |
	*|    |处理方法基本与格式01相同但第1)步PIN明文处理中0x0N||PIN||0xFF…0xFF格式修改为 |
	*|    |0x3N||PIN||0xFF…0xFF格式处理,其余处理与格式01完全相同.                      |
	*|    |例:5位PIN明文92389,12位帐号400000123456;                                     |
	*|    |   1)PIN填充:                                                                |
	*|    |       8字节分组:0x3592389FFFFFFFFF,                                         |
	*| 47 |       16字节分组:0x3592389FFFFFFFFFFFFFFFFFFFFFFFFF;                        |
	*|    |   2)账号填充:                                                               |
	*|    |       8字节分组:0x0000400000123456,                                         |
	*|    |       16字节分组:0x00000000000000000000400000123456;                        |
	*|    |   3)两部分异或:                                                             |
	*|    |       8字节分组:0x3592789FFFEDCBA9,                                         |
	*|    |       16字节分组:0x3592389FFFFFFFFFFFFFBFFFFFEDCBA9.                        |
	*====================================================================================
	*/
	/**
	*@brief 加密机支持的PINBLOCK(字符)格式
	*=============================================================================================
	*|代码|                                       含义                                           |
	*|----+--------------------------------------------------------------------------------------|
	*|    |1)由PIN明文扩展ASCII码表示的ExpandedHex型字符串,如果不足24字节(8字节分组)或32字节(16字|
	*|    |  节分组)则在后面补0x00;                                                              |
	*|    |2)由账号扩展为ASCII码表示的ExpandedHex型字符串,如果不足24字节(8字节分组)或32字节(16字 |
	*|    |  节分组)则在后面补0x00;                                                              |
	*|    |3)以上两个数字块异或即为PINBLOCK                                                      |
	*|    |例:8位PIN明文123456AB,12位帐号400000123456;                                           |
	*|    |   1)PIN填充:                                                                         |
	*| 00 |       8字节分组:0x313233343536414200000000000000000000000000000000,                  |
	*|    |       16字节分组:0x3132333435364142000000000000000000000000000000000000000000000000; |
	*|    |   2)账号填充:                                                                        |
	*|    |       8字节分组:0x343030303030313233343536000000000000000000000000,                  |
	*|    |       16字节分组:0x3430303030303132333435360000000000000000000000000000000000000000; |
	*|    |   3)两部分异或:                                                                      |
	*|    |       8字节分组:0x050203040506707033343536000000000000000000000000,                  |
	*|    |       16字节分组:0x0502030405067070333435360000000000000000000000000000000000000000. |
	*|----+--------------------------------------------------------------------------------------|
	*|    |将PAN与PIN明文串联,按分组长度进行填充,若串联后满足分组长度则不进行填充;否则在右端添加 |
	*|    |N-(MSGLEN%N)个(N-(MSGLEN%N))字符,其中N为分组长度,分组后最右端数据块缺m个字节则补充m个 |
	*| 01 |数值m,最少补1个'1',最多补15个'F'  .                                                   |
	*|    |例:8位PIN明文123456AB,12位帐号400000123456;                                           |
	*|    |   8字节分组:0x343030303030313233343536313233343536414234343434('4');                 |
	*|    |   16字节分组:0x3430303030303132333435363132333435364142434343434343434343434343('C').|
	*|----+--------------------------------------------------------------------------------------|
	*|    |该格式要求PIN及PAN都不能超过16字节(16个字符或数字).                                   |
	*|    |1)由PIN明文扩展ASCII码表示的ExpandedHex型字符串,如果不足16字节则在后面补0x00;         |
	*|    |2)由账号扩展为ASCII码表示的ExpandedHex型字符串,如果不足16字节则在后面补0x00;          |
	*| 03 |3)以上两个数字块异或即为PINBLOCK                                                      |
	*|    |例:8位PIN明文123456AB,12位帐号400000123456;                                           |
	*|    |   1)PIN填充:0x31323334353641420000000000000000;                                      |
	*|    |   2)账号填充:0x34303030303031323334353600000000;                                     |
	*|    |   3)两部分异或:0x05020304050670703334353600000000.                                   |
	*=============================================================================================
	*/
	/**
	*@brief 加密机打印格式符号表
	*===================================================================================================
	*|       符号       |      EBCDIC码     |      ASCII码      |                 说明                 |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        >L        |       6E D3       |       3E 4C       |回车,换行.                            |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        >V        |       6E E5       |       3E 56       |垂直标号.                             |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        >H        |       6E C8       |       3E 48       |水平标号.                             |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        >F        |       6E C6       |       3E 46       |换页.                                 |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|       >nnn       |     6EFnFnFn      |     3E3n3n3n      |从左边缘跳过"nnn"(位的十进制数)列.    |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        ^M        |       5F D6       |        5E         |对于密钥文档,打印第三个明文成份.      |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        ^P        |       5F D7       |        5E         |对于PIN信封,为信封1打印明文PIN;       |
	*|                  |                   |                   |对于密钥文档,打印明文成份.            |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|                  |                   |                   |对于PIN信封,为信封2打印明文PIN.       |
	*|        ^Q        |       5F D8       |        5E         |对于密钥文档,打印明文成份或加密的TMK  |
	*|                  |                   |                   |(仅当"one-up"打印允许).               |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        ^R        |       5F D9       |        5E         |为PIN信封1打印参考数.                 |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        ^S        |       5F E2       |        5E         |为PIN信封2打印参考数.                 |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        ^T        |       5F E3       |        5E         |在PIN信封1中打印帐号的最后六位.       |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        ^U        |       5F E4       |        5E         |在PIN信封2中打印帐号的最后六位.       |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*| |<L><hh hh hh..> | 6A<L><hh hh hh..> | 7C<L><hh hh hh..> |发送二进制数据(如打印机控制字符串)至打|
	*|                  |                   |                   |印机:[|+数据长度L(0-F)+数据hh(00-FF)].|
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        ^0        |       5F F0       |       5E 30       |插入打印域0.                          |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        ^1        |       5F F1       |       5E 31       |插入打印域1.                          |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        …        |        …         |        …         |                  …                  |
	*|------------------+-------------------+-------------------+--------------------------------------|
	*|        ^F        |       5F C6       |       5E 46       |插入打印域15.                         |
	*===================================================================================================
	*/

	/**
	* @brief    释放接口分配的内存
	*
	* @param    memory  [in]    内存地址
	*
	* @return
	*/
	void driver_Free(FRM_INT8_PTR* memory);

	/**
	 * @brief    初始化密码机接口,通过传递的参数指定配置信息
	 *
	 * @param    szConfigure [in]    配置信息路径
	 *
	 * @return   成功返回0,否则返回非0
	 */
	FRM_INT32 STDCALL_ driver_Initialize(FRM_INT8_PTR szConfigure);
	/**
	 * @brief    结束接口调用,释放接口资源
	 *
	 * @return   成功返回0,否则返回非0
	 */
	FRM_INT32 STDCALL_ driver_Finalize();
	//-以下金融IC卡应用主机命令
   //-密钥管理功能,11条指令
   /**
   * @brief    KR指令,产生一条随机密钥,可选的存储到密码机内
   *
   * @param    keyType         [in]    生成的密钥类型,如109/MDK
   * @param    symmAlg         [in]    生成的密钥算法,如X/DES2
   * @param    storeIndex      [in]    生成密钥的存储索引,1-2048时有效,为NULL时不存储
   * @param    storeTag        [in]    密钥存储到加密机时的标签,0到16位字符,storeIndex有效时启用
   * @param    keyCipherByLmk  [out]   生成密钥在LMK下加密的密文
   * @param    keyCheckValue   [out]   生成密钥的校验值
   *
   * @return   成功返回0,否则返回非0
   */
	FRM_INT32 STDCALL_ driverKR_GenerateRandomKey_StoreOptional(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    KD指令,分散产生新密钥,可选的存储到密码机内;当源密钥是 DES 时,不论子密钥是不是DES密钥,都会对子密钥强制做奇校验
	*
	* @param    srcKeyType          [in]    源密钥类型,如109/MDK
	* @param    srcKeyIndexOrCipher [in]    源密钥索引或LMK加密的密文
	* @param    childKeyType        [in]    子密钥类型,如109/MDK
	* @param    childSymmAlg        [in]    子密钥算法,如X/DES2
	* @param    diversifyMode       [in]    分散模式,0-5
	* @param    iv                  [in]    初始向量,当diversifyMode为5时有效
	* @param    diversifyFactor     [in]    分散因子(串联),当diversifyMode为0时每级8字节,
	*                                       当diversifyMode为1/2/3/4时每级16字节,当diversifyMode为4时至少2级分散因子
	* @param    storeIndex          [in]    生成密钥的存储索引,1-2048时有效,为NULL时不存储
	* @param    storeTag            [in]    密钥存储到加密机时的标签,0到16位字符,storeIndex有效时启用
	* @param    keyCipherByLmk      [out]   生成密钥在LMK下加密的密文
	* @param    keyCheckValue       [out]   生成密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKD_DiversifyGenerateNewKey_StoreOptional(
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR childKeyType,
		FRM_INT8_PTR childSymmAlg,
		FRM_INT8_PTR diversifyMode,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    KJ指令,分散产生新密钥,可选的存储到密码机内;当源密钥是DES,子密钥是非 DES 密钥时,不会对子密钥做强制奇校验
	*
	* @param    srcKeyType          [in]    源密钥类型,如109/MDK
	* @param    srcKeyIndexOrCipher [in]    源密钥索引或LMK加密的密文
	* @param    childKeyType        [in]    子密钥类型,如109/MDK
	* @param    childSymmAlg        [in]    子密钥算法,如X/DES2
	* @param    diversifyMode       [in]    分散模式,0-5
	* @param    iv                  [in]    初始向量,当diversifyMode为5时有效
	* @param    diversifyFactor     [in]    分散因子(串联),当diversifyMode为0时每级8字节,
	*                                       当diversifyMode为1/2/3/4时每级16字节,当diversifyMode为4时至少2级分散因子
	* @param    storeIndex          [in]    生成密钥的存储索引,1-2048时有效,为NULL时不存储
	* @param    storeTag            [in]    密钥存储到加密机时的标签,0到16位字符,storeIndex有效时启用
	* @param    keyCipherByLmk      [out]   生成密钥在LMK下加密的密文
	* @param    keyCheckValue       [out]   生成密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKJ_DiversifyGenerateNewKey_StoreOptional(
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR childKeyType,
		FRM_INT8_PTR childSymmAlg,
		FRM_INT8_PTR diversifyMode,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    KH指令,传输密钥保护导出一条密钥
	*
	* @param    algorithmMode               [in]    算法模式,限00/01
	* @param    macMode                     [in]    MAC算法模式,01/03
	* @param    macValueWay                 [in]    MAC取值方式,如08
	* @param    transferKeyType             [in]    传输密钥类型,限000/109或KEK/MDK
	* @param    transferKeyIndexOrCipher    [in]    传输密钥索引或LMK加密的密文
	* @param    transferKeyDiversifyFactor  [in]    传输密钥分散因子(串联),每级8字节,最多8级
	* @param    exportedKeyType             [in]    被导出密钥类型,如109/MDK
	* @param    exportedKeyIndexOrCipher    [in]    被导出密钥索引或LMK加密的密文
	* @param    exportedKeyDiversifyFactor  [in]    被导出密钥分散因子串联,每级8字节,最多8级
	* @param    macKeyType                  [in]    MAC密钥类型,限000/109或KEK/MDK,为NULL时与保护密钥相同
	* @param    macKeyIndexOrCipher         [in]    MAC密钥索引或LMK加密的密文,macKeyType不为NULL时有效
	* @param    macKeyDiversifyFactor       [in]    MAC密钥分散因子(串联),每级8字节,最多8级,macKeyType不为NULL时有效
	* @param    keyHead                     [in]    密钥头,0-32字节；IC卡内存储此密钥的密钥头,用于计算密钥密文,通常为密钥属性
	* @param    cmdHead                     [in]    命令头,0-32字节；IC卡密钥导入命令的命令头,用于计算密文MAC,通常5字节
	* @param    randomNumber                [in]    随机数,0-32字节；IC卡生成的随机数,用于计算密文MAC,通常为4字节
	* @param    iv                          [in]    计算密文MAC的初始向量,8/16字节；长度与密钥算法的分组长度相同
	* @param    keyCipherByTransferKey      [out]   传输密钥加密的密钥密文
	* @param    keyCipherMac                [out]   密钥密文MAC
	* @param    keyCheckValue               [out]   密钥校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKH_TransferKeyExportKey(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR macMode,
		FRM_INT8_PTR macValueWay,
		FRM_INT8_PTR transferKeyType,
		FRM_INT8_PTR transferKeyIndexOrCipher,
		FRM_INT8_PTR transferKeyDiversifyFactor,
		FRM_INT8_PTR exportedKeyType,
		FRM_INT8_PTR exportedKeyIndexOrCipher,
		FRM_INT8_PTR exportedKeyDiversifyFactor,
		FRM_INT8_PTR macKeyType,
		FRM_INT8_PTR macKeyIndexOrCipher,
		FRM_INT8_PTR macKeyDiversifyFactor,
		FRM_INT8_PTR keyHead,
		FRM_INT8_PTR cmdHead,
		FRM_INT8_PTR randomNumber,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* keyCipherByTransferKey,
		FRM_INT8_PTR* keyCipherMac,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    KI指令,传输密钥保护导入一条密钥
	*
	* @param    importType                  [in]    输入类型,0:仅密文；1:密文+MAC
	* @param    algorithmMode               [in]    算法模式,限00/01
	* @param    macMode                     [in]    MAC算法模式,01/03
	* @param    macValueWay                 [in]    MAC取值方式,如08
	* @param    transferKeyType             [in]    传输密钥类型,限000/109或KEK/MDK
	* @param    transferKeyIndexOrCipher    [in]    传输密钥索引或LMK加密的密文
	* @param    transferKeyDiversifyFactor  [in]    传输密钥分散因子(串联),每级8字节,最多8级
	* @param    importedKeyType             [in]    被导出密钥类型,如109/MDK
	* @param    importedKeyAlg              [in]    被导入密钥算法标识,如X/DES2
	* @param    storeIndex                  [in]    被导入密钥存储索引,1-2048有效,为NULL时不存储
	* @param    storeTag                    [in]    被导入密钥存储标签,0-16个字符,storeIndex有效时启用
	* @param    macKeyType                  [in]    MAC密钥类型,限000/109或KEK/MDK,为NULL时与保护密钥相同,importType为1时有效
	* @param    macKeyIndexOrCipher         [in]    MAC密钥索引或LMK加密的密文,macKeyType不为NULL且importType为1时有效
	* @param    macKeyDiversifyFactor       [in]    MAC密钥分散因子(串联),每级8字节,最多8级,
	*                                               macKeyType不为NULL且importType为1时有效
	* @param    keyHead                     [in]    密钥头,0-32字节；IC卡内存储此密钥的密钥头,用于计算密钥密文,通常为密钥属性,
	*                                               输入全00,则不验证密钥头的有效性
	* @param    cmdHead                     [in]    命令头,0-32字节；IC卡密钥导入命令的命令头,用于计算密文MAC,通常5字节
	* @param    randomNumber                [in]    随机数,0-32字节；IC卡生成的随机数,用于计算密文MAC,通常为4字节
	* @param    iv                          [in]    计算密文MAC的初始向量,8/16字节；长度与密钥算法的分组长度相同
	* @param    keyCipherByTransferKey      [in]    传输密钥加密的密钥密文
	* @param    keyCipherMac                [in]    密钥密文MAC,最大8字节,importType为1时有效
	* @param    keyCipherByLmk              [out]   LMK加密的密钥密文
	* @param    keyCheckValue               [out]   密钥校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKI_TransferKeyImportKey(
		FRM_INT8_PTR importType,
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR macMode,
		FRM_INT8_PTR macValueWay,
		FRM_INT8_PTR transferKeyType,
		FRM_INT8_PTR transferKeyIndexOrCipher,
		FRM_INT8_PTR transferKeyDiversifyFactor,
		FRM_INT8_PTR importedKeyType,
		FRM_INT8_PTR importedSymmAlg,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR macKeyType,
		FRM_INT8_PTR macKeyIndexOrCipher,
		FRM_INT8_PTR macKeyDiversifyFactor,
		FRM_INT8_PTR keyHead,
		FRM_INT8_PTR cmdHead,
		FRM_INT8_PTR randomNumber,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR keyCipherByTransferKey,
		FRM_INT8_PTR keyCipherMac,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    SH指令,保护密钥加密导出一条密钥–通用
	*
	* @param    algorithmMode               [in]    加密时的运算模式,限00/01
	* @param    protectKeyType              [in]    保护密钥类型,限000/011/109或ZMK(KEK)/KMC/MDK
	* @param    protectKeyIndexOrCipher     [in]    保护密钥索引或LMK加密的密文
	* @param    protectKeyDiversifyFactor   [in]    保护密钥分散因子,每级16字节,最多3级
	* @param    sessionKeyGenMode           [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor            [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    exportedKeyType             [in]    被导出密钥类型,如109/MDK
	* @param    exportedKeyIndexOrCipher    [in]    被导出密钥索引或LMK加密的密文
	* @param    exportedKeydiversifyFactor  [in]    被导出密钥分散因子,每级16字节,最多3级
	* @param    keyHead                     [in]    密钥头,0-32字节；IC卡内存储此密钥的密钥头,用于计算密钥密文通常为密钥属性,
	*                                               输入全00,则不验证密钥头的有效性
	* @param    padMode                     [in]    输入数据的填充模式,为NULL时使用默认00方式填充和一个分组全00的IV(CBC模式)
	* @param    iv                          [in]    初始向量,algorithmMode为CBC/01且padMode不为NULL时有效
	* @param    keyCipherByProtectKey       [out]   保护密钥加密的密钥密文
	* @param    keyCheckValue               [out]   密钥校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverSH_ProtectKeyExportKey_G(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR protectKeyType,
		FRM_INT8_PTR protectKeyIndexOrCipher,
		FRM_INT8_PTR protectKeyDiversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR exportedKeyType,
		FRM_INT8_PTR exportedKeyIndexOrCipher,
		FRM_INT8_PTR exportedKeyDiversifyFactor,
		FRM_INT8_PTR keyHead,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* keyCipherByProtectKey,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    SI指令,保护密钥加密导入一条密钥–通用
	*
	* @param    algorithmMode                   [in]    解密时的运算模式,限00/01
	* @param    protectKeyType                  [in]    保护密钥类型,限000/011/109或ZMK(KEK)/KMC/MDK
	* @param    protectKeyIndexOrCipher         [in]    保护密钥索引或LMK加密的密文
	* @param    protectKeyDiversifyFactor       [in]    保护密钥分散因子,每级16字节,最多3级
	* @param    sessionKeyGenMode               [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor                [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    importedKeyType                 [in]    被导入密钥类型,如109/MDK
	* @param    importedSymmAlg                 [in]    被导入密钥算法标识,如X/DES2
	* @param    importedKeyCipherByProtectKey   [in]    被导入密钥密文(保护密钥加密)
	* @param    storeIndex                      [in]    被导入密钥存储索引,1-2048有效,为NULL时不存储
	* @param    storeTag                        [in]    被导入密钥存储标签,0-16个字符,storeIndex有效时启用
	* @param    keyHead                         [in]    密钥头,0-32字节；IC卡内存储此密钥的密钥头,
	*                                                   用于计算密钥密文通常为密钥属性,输入全00,则不验证密钥头的有效性
	* @param    padMode                         [in]    输入数据的填充模式,为NULL时使用默认00方式填充,
	*                                                   一个分组全00的IV(CBC模式),不校验密钥校验值
	* @param    iv                              [in]    初始向量,algorithmMode为CBC/01且padMode不为NULL时有效
	* @param    keyCheckValueIn                 [in]    密钥校验值,不超过8字节,为NULL时不校验,padMode不为NULL时有效
	* @param    keyCipherByLmk                  [out]   LMK加密的密钥密文
	* @param    keyCheckValueOut                [out]   密钥校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverSI_ProtectKeyImportKey_G(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR protectKeyType,
		FRM_INT8_PTR protectKeyIndexOrCipher,
		FRM_INT8_PTR protectKeyDiversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR importedKeyType,
		FRM_INT8_PTR importedSymmAlg,
		FRM_INT8_PTR importedKeyCipherByProtectKey,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR keyHead,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR keyCheckValueIn,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValueOut);
	/**
	* @brief    KG指令,获取对称密钥信息
	*
	* @param    keyIndex        [in]    密钥索引号,1-2048有效
	* @param    keyType         [out]   密钥类型,如109
	* @param    symmAlg         [out]   密钥算法,如X
	* @param    keyCheckValue   [out]   密钥校验值
	* @param    storeTag        [out]   密钥标签
	* @param    updateTime      [out]   密钥最后更新时间
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKG_GetSymmetricKeyInfomation(
		FRM_INT8_PTR keyIndex,
		FRM_INT8_PTR* keyType,
		FRM_INT8_PTR* symmAlg,
		FRM_INT8_PTR* keyCheckValue,
		FRM_INT8_PTR* storeTag,
		FRM_INT8_PTR* updateTime);
	/**
	* @brief    KF指令,删除内部指定索引的密钥
	*
	* @param    algType [in]    算法类型,00:对称密钥,01:RSA密钥,02:SM2密钥
	* @param    keyIndex[in]    密钥索引号,对称密钥时1-2048有效；RSA/SM2时1-64有效
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKF_DeleteInternalIndexKey(
		FRM_INT8_PTR algType,
		FRM_INT8_PTR keyIndex);
	/**
	* @brief    KA指令,导入存储一条对称密钥
	*
	* @param    keyType             [in]    密钥类型,如109/MDK
	* @param    keyCipherByLmk      [in]    LMK加密的密钥密文
	* @param    keyCheckValueIn     [in]    密钥校验值,为NULL则不校验
	* @param    storeIndex          [in]    被导入密钥存储索引,1-2048有效
	* @param    storeTag            [in]    被导入密钥存储标签,0-16个字符
	* @param    keyCheckValueOut    [out]   密钥校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKA_LoadStoreSymmetricKey(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyCipherByLmk,
		FRM_INT8_PTR keyCheckValueIn,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* keyCheckValueOut);
	/**
	* @brief    KE指令,分散密钥输出子密钥的多个成分密文
	*
	* @param    srcKeyType          [in]    源密钥类型,如109/MDK
	* @param    srcKeyIndexOrCipher [in]    源密钥索引或LMK加密的密文
	* @param    childKeyType        [in]    子密钥类型,如109/MDK
	* @param    childSymmAlg        [in]    子密钥算法标识,如X/DES2
	* @param    diversifyMode       [in]    分散模式0-3
	* @param    diversifyFactor     [in]    分散因子(串联),diversifyMode为0时每级8字节,其他值时每级16字节,
	*                                       至少1级,至多8级
	* @param    compCount           [in]    输出的密钥成分个数,2-8
	* @param    keyCheckValue       [out]   子密钥校验值
	* @param    comp1Cipher         [out]   密文成分1
	* @param    comp1CheckValue     [out]   成分1校验值
	* @param    comp2Cipher         [out]   密文成分2
	* @param    comp2CheckValue     [out]   成分2校验值
	* @param    comp3Cipher         [out]   密文成分3,无用时填NULL即可
	* @param    comp3CheckValue     [out]   成分3校验值,无用时填NULL即可
	* @param    comp4Cipher         [out]   密文成分4,无用时填NULL即可
	* @param    comp4CheckValue     [out]   成分4校验值,无用时填NULL即可
	* @param    comp5Cipher         [out]   密文成分5,无用时填NULL即可
	* @param    comp5CheckValue     [out]   成分5校验值,无用时填NULL即可
	* @param    comp6Cipher         [out]   密文成分6,无用时填NULL即可
	* @param    comp6CheckValue     [out]   成分6校验值,无用时填NULL即可
	* @param    comp7Cipher         [out]   密文成分7,无用时填NULL即可
	* @param    comp7CheckValue     [out]   成分7校验值,无用时填NULL即可
	* @param    comp8Cipher         [out]   密文成分8,无用时填NULL即可
	* @param    comp8CheckValue     [out]   成分8校验值,无用时填NULL即可
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKE_DiversifyKeyExportCompositionCipher(
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR childKeyType,
		FRM_INT8_PTR childSymmAlg,
		FRM_INT8_PTR diversifyMode,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR compCount,
		FRM_INT8_PTR* keyCheckValue,
		FRM_INT8_PTR* comp1Cipher,
		FRM_INT8_PTR* comp1CheckValue,
		FRM_INT8_PTR* comp2Cipher,
		FRM_INT8_PTR* comp21CheckValue,
		FRM_INT8_PTR* comp3Cipher,
		FRM_INT8_PTR* comp3CheckValue,
		FRM_INT8_PTR* comp4Cipher,
		FRM_INT8_PTR* comp4CheckValue,
		FRM_INT8_PTR* comp5Cipher,
		FRM_INT8_PTR* comp5CheckValue,
		FRM_INT8_PTR* comp6Cipher,
		FRM_INT8_PTR* comp6CheckValue,
		FRM_INT8_PTR* comp7Cipher,
		FRM_INT8_PTR* comp7CheckValue,
		FRM_INT8_PTR* comp8Cipher,
		FRM_INT8_PTR* comp8CheckValue);
	//-GP 规范发卡专用功能,11条指令
	/**
	* @brief    G1指令,厂商KMC加密保护导出发行商KMC三条卡片密钥
	*           每张IC卡出厂时存有厂商的卡片主密钥(3条Kenc/Kmac/Kdek);
	*           在发卡洗卡时需要首先替换成发行商的卡片主密钥(3条Kenc/Kmac/Kdek).
	*           该命令使用厂商KMC(Sdek)加密保护导出发行商KMC密钥(Kenc/Kmac/Kdek),其密文用于替换 IC 卡中的 3 条主密钥.
	* @param    algorithmMode           [in]    导出密钥时的运算模式,限00/01
	* @param    produceKmcIndexOrCipher [in]    制作商KMC密钥索引或LMK加密的密钥密文
	* @param    issueKmcIndexOrCipher   [in]    发行商KMC密钥索引或LMK加密的密钥密文
	* @param    cardPersionKeyData      [in]    卡片个人化密钥数据,6字节,用于分散产生Kenc/Kmac/Kdek,
	*                                           6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter             [in]    卡片计数器, 2字节,用于分散产生Kenc/Kmac/Kdek
	* @param    issueKenc               [out]   厂商Sdek会话密钥加密的发行商Kenc密文,16字节
	* @param    issueKencCheckValue     [out]   厂商Sdek会话密钥加密的发行商Kenc校验值,8字节
	* @param    issueKmac               [out]   厂商Sdek会话密钥加密的发行商Kmac密文,16字节
	* @param    issueKmacCheckValue     [out]   厂商Sdek会话密钥加密的发行商Kmak校验值,8字节
	* @param    issueKdek               [out]   厂商Sdek会话密钥加密的发行商Kdek密文,16字节
	* @param    issueKdekCheckValue     [out]   厂商Sdek会话密钥加密的发行商Kdek校验值,8字节
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverG1_ProduceKMCExportIssueKMC3CardKey(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR produceKmcIndexOrCipher,
		FRM_INT8_PTR issueKmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR* issueKenc,
		FRM_INT8_PTR* issueKencCheckValue,
		FRM_INT8_PTR* issueKmac,
		FRM_INT8_PTR* issueKmacCheckValue,
		FRM_INT8_PTR* issueKdek,
		FRM_INT8_PTR* issueKdekCheckValue);
	/**
	* @brief    G2指令,KMC(Kdek)加密导出多条应用密钥
	*           发行商KMC(使用Sdek会话密钥)加密一系列MDK分散后的卡片密钥,输出密钥密文,用于向IC卡发行灌装.
	*           如需形成安全报文模式另行使用KMC加密数据指令和KMC计算MAC指令.
	*           1.使用发行商KMC,根据IC卡的密钥数据(keydata,由KMCID和芯片序号(CSN)组成,共10字节的最右6字节)分散产生卡片发行商Kdek,
	*             再根据会话密钥因子['0181'||2字节计数器||12 个'00']生成厂商Sdek会话密钥.
	*           2.密码机内组合密钥数据块:[密钥头1||UDK1||密钥头2||UDK2||…密钥头 n||UDKn||800000]
	*             其中UDKn是MDKn根据卡账号分散产生,采用填充模式0对密钥块进行填充；
	*           3.使用Sdek会话密钥按指定算法模式加密该数据块,输出密文.
	* @param    algorithmMode               [in]    加密导出密钥时的运算模式,限00/01
	* @param    kmcIndexOrCipher            [in]    KMC(发行商)密钥索引或LMK加密的密钥密文
	* @param    cardPersionKeyData          [in]    卡片个人化密钥数据,6字节,用于分散产生Kdek,
	*                                               6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter                 [in]    卡片计数器,2字节,用于计算厂商Sdek会话密钥
	* @param    keyHeadLength               [in]    每个密钥头长度,16进制输入,0x0-0x20(即0-32)字节,每个密钥头长度必须一致
	* @param    diversifyFactor             [in]    被导出密钥分散因子(串联),每级16字节(通常8字节PAN||8字节取反),至少1级,至多8级
	* @param    exportedKeyCount            [in]    被导出密钥个数,1-8个,小于8个时后续对应该密钥的参数直接忽略(可填NULL)
	* @param    exportedKey1Type            [in]    被导出密钥1类型
	* @param    exportedKey1IndexOrCipher   [in]    被导出密钥1索引或密文
	* @param    key1Head                    [in]    被导出密钥1密钥头,0-32字节,必须与keyHeadLength指定的一致
	* @param    exportedKey2Type            [in]    被导出密钥2类型
	* @param    exportedKey2IndexOrCipher   [in]    被导出密钥2索引或密文
	* @param    key2Head                    [in]    被导出密钥2密钥头,0-32字节,必须与keyHeadLength指定的一致
	* @param    exportedKey3Type            [in]    被导出密钥3类型
	* @param    exportedKey3IndexOrCipher   [in]    被导出密钥3索引或密文
	* @param    key3Head                    [in]    被导出密钥3密钥头,0-32字节,必须与keyHeadLength指定的一致
	* @param    exportedKey4Type            [in]    被导出密钥4类型
	* @param    exportedKey4IndexOrCipher   [in]    被导出密钥4索引或密文
	* @param    key4Head                    [in]    被导出密钥4密钥头,0-32字节,必须与keyHeadLength指定的一致
	* @param    exportedKey5Type            [in]    被导出密钥5类型
	* @param    exportedKey5IndexOrCipher   [in]    被导出密钥5索引或密文
	* @param    key5Head                    [in]    被导出密钥5密钥头,0-32字节,必须与keyHeadLength指定的一致
	* @param    exportedKey6Type            [in]    被导出密钥6类型
	* @param    exportedKey6IndexOrCipher   [in]    被导出密钥6索引或密文
	* @param    key6Head                    [in]    被导出密钥6密钥头,0-32字节,必须与keyHeadLength指定的一致
	* @param    exportedKey7Type            [in]    被导出密钥7类型
	* @param    exportedKey7IndexOrCipher   [in]    被导出密钥7索引或密文
	* @param    key7Head                    [in]    被导出密钥7密钥头,0-32字节,必须与keyHeadLength指定的一致
	* @param    exportedKey8Type            [in]    被导出密钥8类型
	* @param    exportedKey8IndexOrCipher   [in]    被导出密钥8索引或密文
	* @param    key8Head                    [in]    被导出密钥8密钥头,0-32字节,必须与keyHeadLength指定的一致
	* @param    exportedKeysCipherBySdek    [out]   Sdek加密的被导出密钥密文
	* @param    exportedKey1CheckValue      [out]   导出密钥1校验码
	* @param    exportedKey2CheckValue      [out]   导出密钥2校验码,exportedKeyCount大于1时有效
	* @param    exportedKey3CheckValue      [out]   导出密钥3校验码,exportedKeyCount大于2时有效
	* @param    exportedKey4CheckValue      [out]   导出密钥4校验码,exportedKeyCount大于3时有效
	* @param    exportedKey5CheckValue      [out]   导出密钥5校验码,exportedKeyCount大于4时有效
	* @param    exportedKey6CheckValue      [out]   导出密钥6校验码,exportedKeyCount大于5时有效
	* @param    exportedKey7CheckValue      [out]   导出密钥7校验码,exportedKeyCount大于6时有效
	* @param    exportedKey8CheckValue      [out]   导出密钥8校验码,exportedKeyCount大于7时有效
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverG2_KMC_SdekExportMultiKey(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR kmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR keyHeadLength,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR exportedKeyCount,
		FRM_INT8_PTR exportedKey1Type,
		FRM_INT8_PTR exportedKey1IndexOrCipher,
		FRM_INT8_PTR key1Head,
		FRM_INT8_PTR exportedKey2Type,
		FRM_INT8_PTR exportedKey2IndexOrCipher,
		FRM_INT8_PTR key2Head,
		FRM_INT8_PTR exportedKey3Type,
		FRM_INT8_PTR exportedKey3IndexOrCipher,
		FRM_INT8_PTR key3Head,
		FRM_INT8_PTR exportedKey4Type,
		FRM_INT8_PTR exportedKey4IndexOrCipher,
		FRM_INT8_PTR key4Head,
		FRM_INT8_PTR exportedKey5Type,
		FRM_INT8_PTR exportedKey5IndexOrCipher,
		FRM_INT8_PTR key5Head,
		FRM_INT8_PTR exportedKey6Type,
		FRM_INT8_PTR exportedKey6IndexOrCipher,
		FRM_INT8_PTR key6Head,
		FRM_INT8_PTR exportedKey7Type,
		FRM_INT8_PTR exportedKey7IndexOrCipher,
		FRM_INT8_PTR key7Head,
		FRM_INT8_PTR exportedKey8Type,
		FRM_INT8_PTR exportedKey8IndexOrCipher,
		FRM_INT8_PTR key8Head,
		FRM_INT8_PTR* exportedKeysCipherBySdek,
		FRM_INT8_PTR* exportedKey1CheckValue,
		FRM_INT8_PTR* exportedKey2CheckValue,
		FRM_INT8_PTR* exportedKey3CheckValue,
		FRM_INT8_PTR* exportedKey4CheckValue,
		FRM_INT8_PTR* exportedKey5CheckValue,
		FRM_INT8_PTR* exportedKey6CheckValue,
		FRM_INT8_PTR* exportedKey7CheckValue,
		FRM_INT8_PTR* exportedKey8CheckValue);
	/**
	* @brief    G3指令,KMC(Sdek)加密敏感数据
	*           发行商KMC(使用Sdek会话密钥)加密卡片敏感数据,如脱机PIN等,输出数据密文,用于向IC卡发行灌装.
	*           如需形成安全报文模式另行使用 KMC 加密数据指令和KMC计算MAC指令.
	*           1.使用发行商KMC,根据IC卡的密钥数据(keydata,由KMCID和芯片序号(CSN)组成,共10字节的最右6字节)
	*             分散产生卡片发行商 Kdek,再根据会话密钥因子['0181'||2 字节计数器||12 个'00']生成厂商Sdek会话密钥
	*           2.使用Sdek会话密钥按指定算法模式加密填充后的数据块,输出密文
	* @param    algorithmMode       [in]    导出密钥时的运算模式,限00/01
	* @param    kmcIndexOrCipher    [in]    KMC(发行商)密钥索引或LMK加密的密钥密文
	* @param    cardPersionKeyData  [in]    卡片个人化密钥数据,6字节,用于分散产生卡片Kdek,
	*                                       6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter         [in]    卡片计数器, 2字节,用于计算厂商Sdek会话密钥
	* @param    data                [in]    待加密数据,0-984字节
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    cipher              [out]   密文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverG3_KMC_SdekEncryptSensitiveData(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR kmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR data,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR* cipher);
	/**
	* @brief    G4指令,KMC(Senc)加密数据
	*           发行商KMC(使用Senc会话密钥)加密输入数据,通常用于加密APDU命令报文保证其安全性
	*           如需形成安全报文模式另行使用 KMC 加密数据指令和KMC计算MAC指令.
	*           1.使用发行商KMC,根据IC卡的密钥数据(keydata,由KMCID和芯片序号(CSN)组成,共10字节的最右6字节)
	*             分散产生卡片发行商 Kenc,再根据会话密钥因子['0182'||2 字节计数器||12 个'00']生成厂商Senc会话密钥
	*           2.使用Senc会话密钥按指定算法模式加密填充后的数据块,输出密文
	* @param    algorithmMode       [in]    导出密钥时的运算模式,限00/01
	* @param    kmcIndexOrCipher    [in]    KMC(发行商)密钥索引或LMK加密的密钥密文
	* @param    cardPersionKeyData  [in]    卡片个人化密钥数据,6字节,用于分散产生卡片Kenc,
	*                                       6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter         [in]    卡片计数器, 2字节,用于计算厂商Sdek会话密钥
	* @param    data                [in]    待加密数据,0-984字节
	* @param    padMode             [in]    输入数据的填充模式,取值范围00-05
	* @param    cipher              [out]   密文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverG4_KMC_SencEncryptData(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR kmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR data,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR* cipher);
	/**
	* @brief    G5指令,KMC(Scmac)计算数据 C-MAC
	*           发行商KMC(使用Sc-mac会话密钥)计算数据的MAC,通常用于在需要完整性安全报文的APDU命令中对
	*           [命令头 CLA+INS+P1+P2+Lc||数据域]计算C-MAC.如安全报文模式需要保密性,则请另行使用 KMC 加密数据指令
	*           1.使用发行商KMC,根据IC卡的密钥数据(keydata,由KMCID和芯片序号(CSN)组成,共10字节的最右6字节)
	*             分散产生卡片发行商 Kmac,再根据会话密钥因子['0101'||2 字节计数器||12 个'00']生成厂商Sc-mac会话密钥
	*           2.使用Sc-mac会话密钥按指定模式计算数据块的MAC
	* @param    macMode             [in]    MAC算法模式,01/03
	* @param    kmcIndexOrCipher    [in]    KMC(发行商)密钥索引或LMK加密的密钥密文
	* @param    cardPersionKeyData  [in]    卡片个人化密钥数据,6字节,用于分散产生Kenc/Kmac/Kdek,
	*                                       6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter         [in]    卡片计数器, 2字节,用于分散产生卡片Kmac
	* @param    data                [in]    待加密数据,0-984字节
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    icvMode             [in]    ICV使用模式,0:直接使用ICV参与MAC运算,1:使用Sc-mac左8字节加密ICV后参与运算
	* @param    icv                 [in]    8字节初始化向量
	* @param    mac                 [out]   MAC,16字节
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverG5_KMC_ScmacCalculateDataC_MAC(
		FRM_INT8_PTR macMode,
		FRM_INT8_PTR kmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR data,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR icvMode,
		FRM_INT8_PTR icv,
		FRM_INT8_PTR* mac);
	/**
	* @brief    G6指令,KMC(Srmac)验证数据 R-MAC
	*           发行商KMC(使用Sr-mac会话密钥)验证数据的MAC,通常用于在需要完整性安全报文的APDU命令中对应答数据验证 R-MAC
	*           1.使用发行商KMC,根据IC卡的密钥数据(keydata,由KMCID和芯片序号(CSN)组成,共10字节的最右6字节)
	*             分散产生卡片发行商 Kmac,再根据会话密钥因子['0102'||2 字节计数器||12 个'00']生成厂商Sc-mac会话密钥
	*           2.使用Sr-mac会话密钥按指定模式计算数据块的MAC,与输入的 MAC 值比对,输出验证结果
	* @param    macMode             [in]    MAC算法模式,01/03
	* @param    kmcIndexOrCipher    [in]    KMC(发行商)密钥索引或LMK加密的密钥密文
	* @param    cardPersionKeyData  [in]    卡片个人化密钥数据,6字节,用于分散产生Kenc/Kmac/Kdek,
	*                                       6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter         [in]    卡片计数器, 2字节,用于分散产生卡片Kmac
	* @param    data                [in]    待加密数据,0-984字节
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    icvMode             [in]    ICV使用模式,0:直接使用ICV参与MAC运算,1:使用Sc-mac左8字节加密ICV后参与运算
	* @param    icv                 [in]    8字节初始化向量
	* @param    mac                 [in]    待验证MAC,16字节
	* @param    macByHSM            [out]   当返回错误码1(MAC验证失败)时,此参数为加密机计算的MAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverG6_KMC_SrmacVerifyDataR_MAC(
		FRM_INT8_PTR macMode,
		FRM_INT8_PTR kmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR data,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR icvMode,
		FRM_INT8_PTR icv,
		FRM_INT8_PTR mac,
		FRM_INT8_PTR* macByHSM);
	/**
	* @brief    G7指令,外部认证
	*           适用于卡片与外部实体初始化安全通道时的双向认证,外部实体通过调用 HSM 来完成对卡片的认证工作.
	*           双向认证过程:
	*           1.终端向卡发起INITIALIZE UPDATE命令,并送入一个8字节终端随机数,
	*             SCP02卡片返回[10字节密钥派生数据+2字节密钥信息+2字节计数器+6字节卡随机数+8字节卡片认证密文];
	*           2.终端调用 HSM 完成认证密文的计算:
	*             1)使用发行商KMC,根据IC卡的密钥数据(keydata,由KMCID和芯片序号(CSN)组成,共10字节的最右6字节)
	*               分散产生卡片发行商 Kenc,再根据会话密钥因子['0182'||2 字节计数器||12 个'00']生成厂商Senc会话密钥;
	*             2)组数据包[8字节终端随机数||2字节计数器||6字节卡随机数||8000000000000000],使用Senc会话密钥
	*               对数据包做全CBCMAC,得8字节密文,与IC卡返回的8字节卡片认证密文比对,一致则通过对卡的认证;
	*             3)另组数据包[2字节计数器||6字节卡随机数||8字节终端随机数||8000000000000000],使用Senc会话密钥
	*               对数据包做全CBC MAC,得8字节密文作为终端认证密文输出;
	*           3.终端将HSM返回的认证密文通过EXTERNAL AUTHENTICATE命令送给卡片,进行卡对终端的认证.
	*             完成卡与终端的双向认证.
	*           其中的步骤2的过程,为本指令提供的密码运算功能.
	* @param    kmcIndexOrCipher    [in]    KMC(发行商)密钥索引或LMK加密的密钥密文
	* @param    cardPersionKeyData  [in]    卡片个人化密钥数据,6字节,用于分散产生卡片Kenc,
	*                                       6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    hostChallenge       [in]    终端随机数,8字节
	* @param    cardChallenge       [in]    卡片随机数,8字节,对SCP02,该域为2字节计数器+6字节卡片随机数
	* @param    cardAuthCipher      [in]    卡片认证密文,8字节
	* @param    hostAuthCipher      [out]   主机认证密文,8字节
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverG7_ExternalAuthenticate(
		FRM_INT8_PTR kmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR hostChallenge,
		FRM_INT8_PTR cardChallenge,
		FRM_INT8_PTR cardAuthCipher,
		FRM_INT8_PTR* hostAuthCipher);
	/**
	* @brief    G8指令,保护密钥加密导出KMC三条会话密钥
	*           适用于远程发卡系统,该系统向IC卡加载新的应用.
	*           KMC存储于总行或总中心的密码机内,发卡系统部署于分行或分支机构,分行要对卡片增加一项业务应用时,
	*           发卡系统先对卡片进行外部认证,通过后再将应用applet加密并计算MAC,然后灌装给卡片,
	*           加密和计算MAC的密钥为卡片KMC的会话密钥(Senc/Smac/Sdek).
	*           本指令用于从总行导出KMC的三条会话密钥,由传输密钥加密保护,该传输密钥是分行与总行共享的一条密钥加密密钥.
	*           在进行加密或MAC运算前需使用SI指令导入成本地应用密钥的形式方可使用.
	*           说明,本指令输出的SMAC为计算C-MAC的会话密钥.
	* @param    algorithmMode               [in]    加密时的运算模式,限00/01
	* @param    protectKeyType              [in]    保护密钥类型,限000/109或ZMK(KEK)/MDK
	* @param    protectKeyIndexOrCipher     [in]    保护密钥索引或LMK加密的密文
	* @param    protectKeyDiversifyFactor   [in]    保护密钥分散因子,每级16字节,最多3级
	* @param    sessionKeyGenMode           [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor            [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    kmcIndexOrCipher            [in]    被KMC密钥索引或LMK加密的密文
	* @param    cardPersionKeyData          [in]    卡片个人化密钥数据,6字节,用于分散产生Kenc/Kmac/Kdek,
	*                                               6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter                 [in]    卡片计数器, 2字节,用于分散产生Kenc/Kmac/Kdek
	* @param    sencCipherByProtectKey      [out]   保护密钥加密的Senc密文,16字节
	* @param    sencCheckValue              [out]   Senc密钥校验值,8字节
	* @param    scmacCipherByProtectKey     [out]   保护密钥加密的Scmac密文,16字节
	* @param    scmacCheckValue             [out]   Scmac密钥校验值,8字节
	* @param    sdekCipherByProtectKey      [out]   保护密钥加密的Sdek密文,16字节
	* @param    sdekCheckValue              [out]   Sdek密钥校验值,8字节
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverG8_ProtectKeyExportKMC3SessionKey(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR protectKeyType,
		FRM_INT8_PTR protectKeyIndexOrCipher,
		FRM_INT8_PTR protectKeyDiversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR kmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR* sencCipherByProtectKey,
		FRM_INT8_PTR* sencCheckValue,
		FRM_INT8_PTR* scmacCipherByProtectKey,
		FRM_INT8_PTR* scmacCheckValue,
		FRM_INT8_PTR* sdekCipherByProtectKey,
		FRM_INT8_PTR* sdekCheckValue);
	/**
	* @brief    指令GF,KMC(Sdek)保护导出一对 RSA 密钥
	*           发行商KMC(使用Sdek会话密钥)加密导出一对RSA密钥,输出公钥明文和Sdek加密的各私钥分量密文,用于向IC卡发行灌装;
	*           如需形成安全报文模式另行使用KMC加密数据指令和KMC计算MAC指令
	* @param    algorithmMode           [in]    加密时的运算模式,限00/01
	* @param    kmcIndexOrCipher        [in]    KMC密钥索引或密文
	* @param    cardPersionKeyData      [in]    卡片个人化密钥数据,6字节,用于分散产生卡片Kdek,
	*                                           6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter             [in]    卡片计数器, 2字节,用于计算厂商Sdek会话密钥
	* @param    privateKeyIndexOrCipher [in]    被导出RSA密钥对的索引或在LMK下加密的私钥密文
	* @param    publicKeyDer            [out]   公钥ASN.1格式DER编码(模,指数序列)
	* @param    privateKeyD             [out]   Sdek加密私钥指数d密文
	* @param    privateKeyP             [out]   Sdek加密私钥分量p密文
	* @param    privateKeyQ             [out]   Sdek加密私钥分量p密文
	* @param    privateKeyDp            [out]   Sdek加密私钥分量dp密文
	* @param    privateKeyDq            [out]   Sdek加密私钥分量dp密文
	* @param    privateKeyQinv          [out]   Sdek加密私钥分量qinv密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverGF_KMC_SdekExportRSAKeyPair(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR kmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR* publicKeyDer,
		FRM_INT8_PTR* privateKeyD,
		FRM_INT8_PTR* privateKeyP,
		FRM_INT8_PTR* privateKeyQ,
		FRM_INT8_PTR* privateKeyDp,
		FRM_INT8_PTR* privateKeyDq,
		FRM_INT8_PTR* privateKeyQinv);
	/**
	* @brief    指令G0,KMC(Sdek)保护导出一对SM2密钥
	*
	* @param    algorithmMode           [in]    加密时的运算模式,限00/01
	* @param    kmcIndexOrCipher        [in]    KMC密钥索引或密文
	* @param    cardPersionKeyData      [in]    卡片个人化密钥数据,6字节,用于分散产生Kdek,
	*                                           6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter             [in]    卡片计数器, 2字节,用于计算厂商Sdek会话密钥
	* @param    sm2KeyIndex             [in]    导出的SM2密钥索引,1-64有效,为NULL时导出publicKeyDerIn和privateKeyCipherByLmk描述的密钥对
	* @param    publicKeyDerIn          [in]    公钥DER编码,KeyIndex为NULL时有效
	* @param    privateKeyCipherByLmk   [in]    LMK加密的私钥密文,KeyIndex为NULL时有效
	* @param    publicKeyDerOut         [out]   公钥DER编码
	* @param    privateKeyCipherBySdek  [out]   Sdek密钥加密的私钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverG0_KMC_SdekExportSM2KeyPair(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR kmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR sm2KeyIndex,
		FRM_INT8_PTR publicKeyDerIn,
		FRM_INT8_PTR privateKeyCipherByLmk,
		FRM_INT8_PTR* publicKeyDerOut,
		FRM_INT8_PTR* privateKeyCipherBySdek);
	/**
	* @brief    GD指令,TK加密的PIN密文转为KMC(Sdek)下加密
	*           发卡系统接收到DP发来的TK加密的PIN密文,转换到发行商KMC(使用Sdek会话密钥)下加密,输出数据密文,用于向IC卡发行灌装
	*           该指令支持 PINBLOCK 格式的转换.
	* @param    srcKeyType              [in]    源密钥类型,如109/MDK
	* @param    srcKeyIndexOrCipher     [in]    源密钥索引或LMK加密的密文
	* @param    dstKmcIndexOrCipher     [in]    目标KMC密钥索引或密文
	* @param    cardPersionKeyData      [in]    卡片个人化密钥数据,6字节,用于分散产生Kdek,
	*                                           6字节KMCID和4字节芯片序号(CSN)串联组成10字节数据,取低6字节作为有效数据
	* @param    cardCounter             [in]    卡片计数器, 2字节,用于计算厂商Sdek会话密钥
	* @param    pinBlockCipherBySrcKey  [in]    PINBLOCK密文,8/16字节
	* @param    srcPinBlockFormat       [in]    源密钥下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    srcAccountNum           [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           当srcPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    dstPinBlockFormat       [in]    目标KMC(Sdek)下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    dstAccountNum           [in]    参与目标KMC(Sdek)密钥对PINBLOCK加密运算的帐号(不包含校验位)
	*                                           当dstPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinBlockCipherBySdek    [out]   Sdek密钥加密的PINBLOCK密文,8字节
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverGD_TKPINCipherTransferToKMC_Sdek(
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR dstKmcIndexOrCipher,
		FRM_INT8_PTR cardPersionKeyData,
		FRM_INT8_PTR cardCounter,
		FRM_INT8_PTR pinBlockCipherBySrcKey,
		FRM_INT8_PTR srcPinBlockFormat,
		FRM_INT8_PTR srcAccountNum,
		FRM_INT8_PTR dstPinBlockFormat,
		FRM_INT8_PTR dstAccountNum,
		FRM_INT8_PTR* pinBlockCipherBySdek);
	//-PBOC/EMV 规范交易功能,6条指令
	/**
	* @brief    K6指令,验证一个ARQC(or TC/ACC),并且可选的产生一个ARPC,也可以用做单独产生ARPC
	*           若验证ARQC,则填充交易数据(填充模式采用模式 1)后,
	*           使用会话密钥SDK计算其ARQC值,与输入的ARQC对比,若失败则输出诊断数据；
	*           当MDK源密钥为3DES算法时,依PBOC2.0规范,ARQC为交易数据的8字节MAC值；
	*           当MDK源密钥为AES/SM1算法时,依PBOC2.0规范,ARQC为交易数据的16字节MAC值左右异或后的 8 字节结果数据；
	*           当MDK源密钥为SM4算法时,依PBOC3.0规范,ARQC为交易数据的16字节MAC值的左8字节数据
	* @param    modeFlag            [in]    模式标识,0:ARQC验证,1:ARQC验证和ARPC生成,2:产生ARPC
	* @param    keyIndexOrCipher    [in]    MK-AC/MDK类型密钥索引或LMK加密的密文
	* @param    pan                 [in]    PAN,0-16位数字
	* @param    atc                 [in]    ATC,2字节,计算会话密钥
	* @param    tradeData           [in]    交易数据,用于验证APQC,modeFlag为1时启用
	* @param    arqcOrTcOrAac       [in]    ARQC/TC/AAC,8字节
	* @param    arc                 [in]    ARC,用于产生ARPC,modeFlag为1或2时启用
	* @param    arpc                [out]   ARPC,modeFlag为1或2时输出
	* @param    arqcByHsm           [out]   加密机计算的ARQC,modeFlag为0或1时且错误码为01(ARQC验证失败)时输出
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverK6_PBOCVerifyARQC_TC_AAC_GenerateARPCOptional(
		FRM_INT8_PTR modeFlag,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR pan,
		FRM_INT8_PTR atc,
		FRM_INT8_PTR tradeData,
		FRM_INT8_PTR arqcOrTcOrAac,
		FRM_INT8_PTR arc,
		FRM_INT8_PTR* arpc,
		FRM_INT8_PTR* arqcByHsm);
	/**
	* @brief    K2指令,PBOC 脚本加密
	*           分散 MDK 源密钥产生卡片主密钥 UDK,根据 ATC 值计算交易会话密钥 SDK；
	*           对输入数据进行填充(填充模式0),使用 SDK 进行加密运算, 输出密文数据
	* @param    keyIndexOrCipher[in]    MK-AC/MDK类型密钥索引或LMK加密的密文
	* @param    pan             [in]    PAN,0-16位数字
	* @param    atc             [in]    ATC,2字节,计算会话密钥
	* @param    data            [in]    脚本数据,0-984字节
	* @param    cipher          [out]   加密后的数据密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverK2_PBOCScriptEncrypt(
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR pan,
		FRM_INT8_PTR atc,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* cipher);
	/**
	* @brief    K4指令,PBOC脚本MAC
	*           分散MDK源密钥产生卡片主密钥 UDK,根据 ATC 值计算交易会话密钥 SDK；
	*           对输入数据进行填充(填充模式采用模式1),使用SDK进行MAC运算,输出；
	*           当MDK源密钥为双长度3DES密钥时,采用ISO9797-1的MAC算法3,输出8字节MAC结果；
	*           当MDK源密钥为SM1/SM4/AES密钥时,采用ISO9797-1的MAC算法1,输出16字节MAC结果
	* @param    keyIndexOrCipher[in]    MK-AC/MDK类型密钥索引或LMK加密的密文
	* @param    pan             [in]    PAN,0-16位数字
	* @param    atc             [in]    ATC,2字节,计算会话密钥
	* @param    data            [in]    脚本数据,0-984字节
	* @param    mac             [out]   脚本MAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverK4_PBOCScriptMAC(
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR pan,
		FRM_INT8_PTR atc,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* mac);
	/**
	* @brief    KW指令,EMV4.X验证ARQC/TC/AAC,可选的产生ARPC
	*           支持 EMV2000 规范和 PBOC2.0 规范,该指令目前版本仅支持 3DES 算法
	* @param    modeFlag            [in]    模式标识,0:ARQC验证,
	*                                       1:执行ARQC验证,和EMV4.1方法一ARPC产生,2:仅执行EMV4.1方法一ARPC产生,
	*                                       3:执行ARQC验证,和EMV4.1方法二ARPC产生,4:仅执行EMV4.1方法二ARPC产生
	* @param    schemeId            [in]    指定密钥离散方案
	*                                       0:VIS1.4.0 或 M/Chip4 使用 EMV4.1 卡密钥离散方法 A 及EMV2000 会话密钥离散方式
	*                                       1:VIS1.4.0 或 M/Chip4 使用 EMV4.1 卡密钥离散方法 B 及EMV2000 会话密钥离散方式
	*                                       2:VIS1.4.0 或 M/Chip4 使用 EMV4.1 卡密钥离散方法 A 及 EMV通用会话密钥离散方式
	*                                       3:VIS1.4.0 或 M/Chip4 使用 EMV4.1 卡密钥离散方法 B 及 EMV通用会话密钥离散方式
	*                                       9:PBOC2.0
	* @param    keyIndexOrCipher    [in]    MK-AC/MDK类型密钥索引或LMK加密的密文
	* @param    iv_ac               [in]    用于离散产生卡片会话密钥的初始向量(EMV2000过程密钥离散方式使用),
	*                                       仅当schemeId为0/1时存在
	* @param    pan                 [in]    PAN,8-99位数字,仅当schemeId为1/3时存在
	* @param    b_hParam            [in]    分支因子和数高参数,用于产生会话密钥(EMV2000过程密钥离散方式使用)
	*                                       0: B为2,H为16,1: B为4,H为8, 仅当schemeId为0/1时存在
	* @param    atc                 [in]    ATC,2字节,计算会话密钥
	* @param    tradeData           [in]    交易数据,用于验证APQC,仅当modeFlag为0/1/3时存在
	* @param    arqcOrTcOrAac       [in]    ARQC/TC/AAC,8字节
	* @param    arc                 [in]    ARC,2字节,用于产生ARPC,仅当modeFlag为1/2时存在
	* @param    csu                 [in]    CSU,4字节,卡状态更新值,用于计算ARPC,仅当modeFlag为3/4时存在
	* @param    authenticateData    [in]    认证数据,0-8字节,用于产生ARPC,仅当modeFlag为3/4时存在
	* @param    arpc                [out]   ARPC,modeFlag为1/2/3/4时输出
	* @param    arqcOrTcOrAacByHsm  [out]   加密机计算的ARQC/TC/ACC,
	*                                       modeFlag为0或1时且错误码为01(ARQC/TC/AAC校验失败验证失败)时输出
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKW_EMV4_XVerifyARQC_TC_AAC_GenerateARPCOptional(
		FRM_INT8_PTR modeFlag,
		FRM_INT8_PTR schemeId,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR iv_ac,
		FRM_INT8_PTR pan,
		FRM_INT8_PTR b_hParam,
		FRM_INT8_PTR atc,
		FRM_INT8_PTR tradeData,
		FRM_INT8_PTR arqcOrTcOrAac,
		FRM_INT8_PTR arc,
		FRM_INT8_PTR csu,
		FRM_INT8_PTR authenticateData,
		FRM_INT8_PTR* arpc,
		FRM_INT8_PTR* arqcOrTcOrAacByHsm);
	/**
	* @brief    KY指令,EMV4.X脚本安全报文／PIN修改
	*           为发卡行到卡片产生一个包含MAC的安全信息,并且可选地包含加密数据以及用在PINCHANGE功能中的PIN密文.
	*           安全报文中的密文信息的输入形式也是被其他密钥加密的,本命令将完成密钥的转换工作,另外对于PIN还包括PINBLOCK格式的转换.
	*           万事达规范PINBLOCK填充密钥使用应用认证密钥(MK-AC)的子密钥,但是PBOC标准定义的可能使用的是离散PIN加密的子密钥,本指令现在均使用VISA标准计算.
	*           该指令目前版本仅支持 3DES 算法.
	* @param    modeFlag                [in]    模式标识,
	*                                           0 = 仅计算MAC(使用EMV4.1卡密钥离散方法A及EMV2000会话密钥离散方式)
	*                                           2 = MAC计算和数据加密
	*                                           4 = MAC计算和PIN CHANGE
	*                                           5 = 仅计算MAC(使用方案ID指定算法)
	* @param    schemeId                [in]    仅当"模式标志"为2、4或5时存在指定密钥离散及加密方案
	*                                           0 = VIS1.4.0使用EMV4.1卡密钥离散方法A及EMV2000会话密钥离散方式(与modeFlag=0相同)
	*                                           1 = M/Chip4使用EMV4.1卡密钥离散方法A及EMV2000会话密钥离散方式
	*                                           4 = CCD使用EMV4.1卡密钥离散方法B及EMV2000会话密钥离散方式
	*                                           5 = VIS1.4.0使用EMV4.1卡密钥离散方法A及EMV通用会话密钥离散方式
	*                                           6 = M/Chip4使用EMV4.1卡密钥离散方法A及EMV通用会话密钥离散方式
	*                                           7 = CCD使用EMV4.1卡密钥离散方法B及EMV通用会话密钥离散方式
	*                                           9 = PBOC2.0
	* @param    mk_smiIndexOrCipher     [in]    MK-SMI类型密钥索引或LMK加密的密文,用于计算MAC
	* @param    iv_smi                  [in]    仅当modeFlag为0,或schemeId为0、1或4时存在
	*                                           用于离散产生MAC计算的卡片会话密钥的初始向量(EMV2000过程密钥离散方式使用)
	* @param    pan                     [in]    PAN,8-99位数字,仅当schemeId为4/7时存在
	* @param    b_hParam                [in]    分支因子和数高参数,仅当modeFlag为0,或schemeId为0、1或4时存在
	*                                           0: B为2,H为16,1: B为4,H为8
	* @param    atc                     [in]    ATC,2字节,用于按EMV2000和PBOC会话密钥离散方式产生会话密钥,
	*                                           仅当modeFlag为0,或schemeId为0、1、4或9时存在
	* @param    ac                      [in]    应用密文,8字节,用于按EMV通用会话密钥离散方式产生会话密钥,
	*                                           仅当schemeId为5、6或7时存在
	* @param    plainData               [in]    用于参与MAC计算的明文数据,0-984字节
	* @param    mk_smcIndexOrCipher     [in]    MK-SMC类型密钥索引或LMK加密的密文,用于加密计算的主密钥索引或密文,
	*                                           仅当modeFlag为2或4时存在
	* @param    iv_smc                  [in]    仅当modeFlag为2或4时或schemeId为0、1或4时存在,
	*                                           用于离散产生加密计算的卡片会话密钥的初始数据(EMV2000会话密钥离散方式使用)
	* @param    tkIndexOrCipher         [in]    输入的密文数据的源加密密钥(ZEK/DEK)的索引或密文,仅当modeFlag为2时存在
	* @param    offset                  [in]    偏移量,在计算MAC时,仅当modeFlag为2或4时存在,
	*                                           将MK-SMC卡片会话密钥加密的密文数据插入到参与MAC计算的明文数据的位置
	* @param    cipherData              [in]    仅当modeFlag为2或4时存在,TK加密的密文数据或ZPK/TPK加密的PINBLOCK密文,
	*                                           TK加密的数据将不做任何改变的转换到MK-SMC卡片过程密钥下加密;
	*                                           dstPinBlockFormat为42时,该域由当前PIN密文右边连接新PIN密文组成
	* @param    srcPinKeyType           [in]    源PIN加密密钥类型,0:ZPK,1:TPK,仅当modeFlag为4时存在
	* @param    srcPinKeyIndexOrCipher  [in]    源PIN加密密钥索引或密文,仅当modeFlag为4时存在
	* @param    srcPinBlockFormat       [in]    源PINBLOCK格式,参见PINBLOCK(数字)格式,仅当modeFlag为4时存在
	* @param    dstPinBlockFormat       [in]    指定MK-SMC会话密钥加密PIN块时的格式:
	*                                           34:标准EMV格式,35:Mastercard格式
	*                                           41:VISA/PBOC不使用当前PIN,42:VISA/PBOC使用当前PIN
	* @param    accountNum              [in]    PIN转换中使用的帐号(不包含校验位),仅当modeFlag为4时存在,
	*                                           当srcPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    mk_acIndexOrCipher      [in]    MK-AC类型密钥索引或LMK加密的密文,产生PINBLOCK的填充(UDK-A)发卡行应用主密钥
	*                                           仅当modeFlag为4且dstPinBlockFormat为41或42时存在
	* @param    mac                     [out]   MAC计算结果8字节
	* @param    re_encryptCipher        [out]   MK-SMC卡片会话密钥重新的加密的密文数据,仅当modeFlag为2或4时存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKY_EMV4_XScriptMAC_PINModify(
		FRM_INT8_PTR modeFlag,
		FRM_INT8_PTR schemeId,
		FRM_INT8_PTR mk_smiIndexOrCipher,
		FRM_INT8_PTR iv_smi,
		FRM_INT8_PTR pan,
		FRM_INT8_PTR b_hParam,
		FRM_INT8_PTR atc,
		FRM_INT8_PTR ac,
		FRM_INT8_PTR plainData,
		FRM_INT8_PTR mk_smcIndexOrCipher,
		FRM_INT8_PTR iv_smc,
		FRM_INT8_PTR tkIndexOrCipher,
		FRM_INT8_PTR offset,
		FRM_INT8_PTR cipherData,
		FRM_INT8_PTR srcPinKeyType,
		FRM_INT8_PTR srcPinKeyIndexOrCipher,
		FRM_INT8_PTR srcPinBlockFormat,
		FRM_INT8_PTR dstPinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR mk_acIndexOrCipher,
		FRM_INT8_PTR* mac,
		FRM_INT8_PTR* re_encryptCipher);
	/**
	* @brief    KX指令,PBOC 脱机 PIN 修改/加密
	*           密钥分散并计算会话密钥后,按 PINBLOCK 格式加密 PIN,用于卡片重置脱机 PIN.
	*           当前版本支持 PBOC3.0 规范的密钥分散和会话密钥离散方式,支持 3DES、 AES 及SM1/SM4 算法应用.
	*           支持输入明文 PIN 模式和密文 PIN 模式.
	*           卡片会话密钥加密前的 PIN 块为 8 字节,采用 10 模式填充后再加密.
	* @param    appMainKeyIndexOrCipher         [in]    MK-AC/MDK类型应用主密钥索引或LMK加密的密文
	* @param    pan                             [in]    PAN,0-16位数字
	* @param    atc                             [in]    ATC,2字节,计算会话密钥
	* @param    pinBlockFormat1                 [in]    指定卡片会话密钥下加密PIN数据块的格式代码:
	*                                                   34:标准EMV格式,35:Mastercard格式
	*                                                   41:VISA/PBOC不使用当前PIN,42:VISA/PBOC使用当前PIN
	* @param    pinInputMode                    [in]    PIN输入模式,1:明文PIN,2:ZPK加密PIN,3:TPK加密PIN
	* @param    plainPinNew                     [in]    新明文PIN,4-12位数字,pinInputMode为1时存在
	* @param    plainPinOld                     [in]    旧明文PIN,4-12位数字,pinInputMode为1且pinBlockFormat1为42时存在
	* @param    pinKeyIndexOrCipher             [in]    加密 PIN 的源 ZPK/TPK 密钥索引或密文,pinInputMode不为1时存在
	* @param    pinBlockFormat2                 [in]    ZPK/TPK 下加密 PIN 数据块的格式代码,参见PINBLOCK(数字)格式,
	*                                                   pinInputMode不为1时存在
	* @param    PinBlockCipherNew               [in]    新密文PIN,8/16字节,pinInputMode不为1时存在
	* @param    PinBlockCipherOld               [in]    旧密文PIN,8/16字节,pinInputMode不为1且pinBlockFormat1为42时存在
	* @param    accountNum                      [in]    参与PINBLOCK加密运算的帐号(不包含校验位)
	*                                                   pinBlockFormat2为4时18位数字,不足左补F,其余情况12位数字
	* @param    pinBlockCipherByCardSessionKey  [out]   卡片会话密钥加密的 PIN 密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKX_PBOCOfflinePINModify_Encrypt(
		FRM_INT8_PTR appMainKeyIndexOrCipher,
		FRM_INT8_PTR pan,
		FRM_INT8_PTR atc,
		FRM_INT8_PTR pinBlockFormat1,
		FRM_INT8_PTR pinInputMode,
		FRM_INT8_PTR plainPinNew,
		FRM_INT8_PTR plainPinOld,
		FRM_INT8_PTR pinKeyIndexOrCipher,
		FRM_INT8_PTR pinBlockFormat2,
		FRM_INT8_PTR PinBlockCipherNew,
		FRM_INT8_PTR PinBlockCipherOld,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR* pinBlockCipherByCardSessionKey);
	//-数据加密解密运算,5条指令
	/**
	* @brief    D3指令,数据加密
	*
	* @param    algorithmMode       [in]    加密时的运算模式,如00/ECB
	* @param    keyType             [in]    密钥类型,如00A/ZEK/DEK
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子(串联),每级8字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-04
	* @param    sessionKeyFactor    [in]    会话密钥因子,2字节,一般为ATC,当sessionKeyGenMode值为01/02时有效
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    data                [in]    待加密数据,0-984字节
	* @param    iv                  [in]    初始向量,algorithmMode为01/02/03或CBC/CFB/OFB时有效
	* @param    cipher              [out]   密文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverD3_DataEncrypt(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* cipher);
	/**
	* @brief    D4指令,数据解密
	*
	* @param    algorithmMode       [in]    解密时的运算模式,如00/ECB
	* @param    keyType             [in]    密钥类型,如00A/ZEK/DEK
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子(串联),每级8字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-04
	* @param    sessionKeyFactor    [in]    会话密钥因子,2字节,一般为ATC,当sessionKeyGenMode值为01/02时有效
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    data                [in]    待解密数据,0-992字节
	* @param    iv                  [in]    初始向量,algorithmMode为01/02/03或CBC/CFB/OFB时有效
	* @param    plain               [out]   明文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverD4_DataDecrypt(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* plain);

	/**
	* @brief    S3指令,数据加密-通用,源密钥ECB模式加密分散因子(每级16字节)得到目标子密钥
	*
	* @param    algorithmMode       [in]    加密时的运算模式,如00/ECB
	* @param    keyType             [in]    密钥类型,如00A:ZEK/DEK
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子,每级16字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor    [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    data                [in]    待加密数据,0-4096字节
	* @param    iv                  [in]    初始向量,algorithmMode为01/02/03或CBC/CFB/OFB时有效
	* @param    cipher              [out]   输出密文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverS3_DataEncrypt_G(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* cipher);
	/**
	* @brief    数据加密-FPE,源密钥ECB模式加密分散因子(每级16字节)得到目标子密钥
	*
	* @param    algorithmMode       [in]    加密时的运算模式,如00/ECB
	* @param    keyType             [in]    密钥类型,如109/MDK
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子,每级16字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor    [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    data                [in]    待加密数据,0-1968字节
	* @param    iv                  [in]    初始向量,algorithmMode为01/02/03或CBC/CFB/OFB时有效
	* @param    tweak               [in]    可选域，仅当加密算法模式为FPE时存在Tweak
	* @param    dataType            [in]    可选域，仅当加密算法模式为FPE时存在
	*                                        00 – 其他类型（标准）；
	*                                        01 - 其他类型（非标准）；
	* @param    radix               [in]    可选域，仅当待加密数据类型为00或01时存在
	* @param    cipher              [out]   输出密文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_  driverS3_DataEncrypt_G_V1(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR tweak,
		FRM_INT8_PTR encDataType,
		FRM_INT8_PTR radix,
		FRM_INT8_PTR* cipher);
	/**
	* @brief    S4指令,数据解密-通用,源密钥ECB模式加密分散因子(每级16字节)得到目标子密钥
	*
	* @param    algorithmMode       [in]    解密时的运算模式,如00/ECB
	* @param    keyType             [in]    密钥类型,如00A:ZEK/DEK
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子,每级16字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor    [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    data                [in]    待解密数据,0-4096字节
	* @param    iv                  [in]    初始向量,algorithmMode为01/02/03或CBC/CFB/OFB时有效
	* @param    plain               [out]   输出明文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverS4_DataDecrypt_G(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* plain);
	/**
	* @brief   数据解密-FPE,源密钥ECB模式加密分散因子(每级16字节)得到目标子密钥
	*
	* @param    algorithmMode       [in]    解密时的运算模式,如00/ECB
	* @param    keyType             [in]    密钥类型,如109/MDK
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子,每级16字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor    [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    data                [in]    待解密数据,0-1984字节
	* @param    iv                  [in]    初始向量,algorithmMode为01/02/03或CBC/CFB/OFB时有效
	* @param    tweak               [in]    可选域，仅当加密算法模式为FPE时存在Tweak
	* @param    decDataType         [in]    可选域，仅当解密算法模式为FPE时存在
	*                                        00 – 其他类型（标准）；
	*                                        01	- 其他类型（非标准）；
	* @param    radix               [in]    当待加密数据类型为00时，取值10或36
	* @param    plain               [out]   输出明文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverS4_DataDecrypt_G_V1(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR tweak,
		FRM_INT8_PTR decDataType,
		FRM_INT8_PTR radix,
		FRM_INT8_PTR* plain);
	/**
	* @brief    S5指令,数据转加密-通用,将源密钥A加密的数据密文转换到目标密钥B下加密
	*
	* @param    srcAlgorithmMode        [in]    源密钥加密时的运算模式,如00/ECB
	* @param    srcKeyType              [in]    密钥类型,如00A:ZEK/DEK
	* @param    srcKeyIndexOrCipher     [in]    源密钥索引或LMK加密的密文
	* @param    srcDiversifyFactor      [in]    源密钥分散因子,每级16字节,最多8级
	* @param    srcSessionKeyGenMode    [in]    源密钥会话密钥产生模式,00-05
	* @param    srcSessionKeyFactor     [in]    源密钥会话密钥因子,当srcSessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    srcPadMode              [in]    源密钥加密时数据的填充模式,如00
	* @param    srcIv                   [in]    源密钥初始向量,algorithmMode为01/02/03或CBC/CFB/OFB时有效
	* @param    dstAlgorithmMode        [in]    目标密钥加密时的运算模式,如00/ECB
	* @param    dstKeyType              [in]    目标密钥类型,如109/MDK
	* @param    dstKeyIndexOrCipher     [in]    目标密钥索引或LMK加密的密文
	* @param    dstDiversifyFactor      [in]    目标密钥分散因子,每级16字节,最多8级
	* @param    dstSessionKeyGenMode    [in]    目标密钥会话密钥产生模式,00-05
	* @param    dstSessionKeyFactor     [in]    目标密钥会话密钥因子,当dstSessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    dstPadMode              [in]    目标密钥加密时数据的填充模式,如00
	* @param    dstIv                   [in]    目标密钥初始向量,algorithmMode为01/02/03或CBC/CFB/OFB时有效
	* @param    cipherBySrcKey          [in]    源密钥加密数据,0-1984字节
	* @param    cipherByDstKey          [out]   目标密钥加密数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverS5_DataCipherTransfer_G(
		FRM_INT8_PTR srcAlgorithmMode,
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR srcDiversifyFactor,
		FRM_INT8_PTR srcSessionKeyGenMode,
		FRM_INT8_PTR srcSessionKeyFactor,
		FRM_INT8_PTR srcPadMode,
		FRM_INT8_PTR srcIv,
		FRM_INT8_PTR dstAlgorithmMode,
		FRM_INT8_PTR dstKeyType,
		FRM_INT8_PTR dstKeyIndexOrCipher,
		FRM_INT8_PTR dstDiversifyFactor,
		FRM_INT8_PTR dstSessionKeyGenMode,
		FRM_INT8_PTR dstSessionKeyFactor,
		FRM_INT8_PTR dstPadMode,
		FRM_INT8_PTR dstIv,
		FRM_INT8_PTR cipherBySrcKey,
		FRM_INT8_PTR* cipherByDstKey);
	//-数据MAC运算,4条指令
	/**
	* @brief    D0指令,计算数据 MAC/TAC
	*
	* @param    macMode             [in]    MAC算法模式,01/03
	* @param    macValueWay         [in]    MAC取值方式,如08
	* @param    keyType             [in]    密钥类型,如109/MDK
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子(串联),每级8字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-04
	* @param    sessionKeyFactor    [in]    会话密钥因子,2字节,一般为ATC,当sessionKeyGenMode值为01/02时有效
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    data                [in]    待计算MAC数据,0-984字节
	* @param    iv                  [in]    初始向量,8/16字节；长度与密钥算法的分组长度相同
	* @param    macOrTac            [out]   MAC或TAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverD0_CalculateDataMAC_TAC(
		FRM_INT8_PTR macMode,
		FRM_INT8_PTR macValueWay,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* macOrTac);
	/**
	* @brief    D1指令,验证数据 MAC/TAC
	*
	* @param    macMode             [in]    MAC算法模式,01/03
	* @param    macValueWay         [in]    MAC取值方式,如08
	* @param    keyType             [in]    密钥类型,如109/MDK
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子(串联),每级8字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-04
	* @param    sessionKeyFactor    [in]    会话密钥因子,2字节,一般为ATC,当sessionKeyGenMode值为01/02时有效
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    data                [in]    待验证MAC数据,0-984字节
	* @param    iv                  [in]    初始向量,8/16字节；长度与密钥算法的分组长度相同
	* @param    macOrTac            [in]    MAC或TAC
	* @param    macOrTacByHSM       [out]   当返回错误码1(MAC验证失败)时,此参数为加密机计算的MAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverD1_VerifyDataMAC_TAC(
		FRM_INT8_PTR macMode,
		FRM_INT8_PTR macValueWay,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR macOrTac,
		FRM_INT8_PTR* macOrTacByHSM);
	/**
	* @brief    S0指令,计算数据MAC/TAC–通用
	*
	* @param    macMode             [in]    MAC算法模式,01/03
	* @param    macValueWay         [in]    MAC取值方式,如08
	* @param    keyType             [in]    密钥类型,如109/MDK
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子(串联),每级16字节,最多3级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor    [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    padMode             [in]    输入数据的填充模式,如00
	* @param    data                [in]    待加密数据,0-4096字节
	* @param    iv                  [in]    初始向量,8/16字节；长度与密钥算法的分组长度相同
	* @param    macOrTac            [out]   MAC或TAC
	* @param    macOrTacCipher      [out]   输出MAC密文,当源密钥为 X/U 类型时存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverS0_CalculateDataMAC_TAC_G(
		FRM_INT8_PTR macMode,
		FRM_INT8_PTR macValueWay,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* macOrTac,
		FRM_INT8_PTR* macOrTacCipher);
	/**
	* @brief    LR指令,采用明文密钥对输入数据计算 HMAC 值  (此指令不建议使用)
	*
	* @param    hashFlag[in]    HASH算法模式标识,限01/02
	* @param    keyPlain[in]    密钥明文,1-256字节
	* @param    data    [in]    输入数据,1-1984字节
	* @param    hmac    [out]   HMAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverLR_CalculateDataHMAC_PlainKey(
		FRM_INT8_PTR hashFlag,
		FRM_INT8_PTR keyPlain,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* hmac);
	//-数据摘要运算,4条指令
	/**
	* @brief   3C指令,计算单包数据摘要
	*
	* @param    hashFlag        [in]    HASH算法模式标识:
	*                                   03:ISO 10118-2
	*                                   05:SHA-224, 06:SHA-256, 07:SHA-384
	*                                   08:SHA-512, 20:SM3-256
	* @param    data            [in]    数据,0-4096字节
	* @param    userId          [in]    用户ID,0-32字节,hashFlag为20(SM3-256)时有效,
	*                                   为NULL时表示不带ID的SM3算法或使用国密局默认ID:1234567812345678
	* @param    sm2PublicKeyDer [in]    SM2算法公钥ASN.1格式DER编码,
	*                                   若sm2PublicKeyDer不为NULL且userId为NULL时使用国密局默认ID:1234567812345678,
	*                                   若sm2PublicKeyDer和userId均为NULL时表示不带ID的SM3算法
	* @param    hash            [out]   HASH
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driver3C_CalculateSinglePacketDigest(
		FRM_INT8_PTR hashFlag,
		FRM_INT8_PTR data,
		FRM_INT8_PTR userId,
		FRM_INT8_PTR sm2PublicKeyDer,
		FRM_INT8_PTR* hash);
	/**
	* @brief    H1指令,大包数据摘要的初始化
	*
	* @param    hashFlag        [in]    HASH算法模式标识:
	*                                   03:ISO 10118-2
	*                                   05:SHA-224, 06:SHA-256, 07:SHA-384
	*                                   08:SHA-512, 20:SM3-256
	* @param    userId          [in]    用户ID,0-32字节,hashFlag为20(SM3-256)时有效,
	*                                   为NULL时表示不带ID的SM3算法或使用国密局默认ID:1234567812345678
	* @param    sm2PublicKeyDer [in]    SM2算法公钥ASN.1格式DER编码,
	*                                   若sm2PublicKeyDer不为NULL且userId为NULL时使用国密局默认ID:1234567812345678,
	*                                   若sm2PublicKeyDer和userId均为NULL时表示不带ID的SM3算法
	* @param    hashContext     [out]   HASHCONTEXT摘要上下文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverH1_MultiPacketDigestInitialize(
		FRM_INT8_PTR hashFlag,
		FRM_INT8_PTR userId,
		FRM_INT8_PTR sm2PublicKeyDer,
		FRM_INT8_PTR* hashContext);
	/**
	* @brief    H2指令,大包数据摘要的过程运算
	*
	* @param    hashContextIn   [in]    上一次H1/H2指令返回的HASHCONTEXT摘要上下文
	* @param    data            [in]    数据,0-984字节
	* @param    hashContextOut  [out]   HASHCONTEXT摘要上下文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverH2_MultiPacketDigestCalculate(
		FRM_INT8_PTR hashContextIn,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* hashContextOut);
	/**
	* @brief    H3指令,大包数据摘要的结束,输出摘要结果
	*
	* @param    hashContext [in]    上一次H1/H2指令返回的HASHCONTEXT摘要上下文，0-984字节
	* @param    hash        [out]   HASH
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverH3_MultiPacketDigestFinalize_OutputDigest(
		FRM_INT8_PTR hashContext,
		FRM_INT8_PTR* hash);
	//-PIN安全管理,10条指令
	/**
	* @brief    P0指令,产生指定长度的随机字符PIN
	*           随机产生指定长度的字符PIN,并由ZPK加密输出.
	* @param    pinLength           [in]    待产生的随机PIN的长度,4-16
	* @param    zpkIndexOrCipher    [in]    ZPK密钥索引或LMK加密的密文
	* @param    pinBlockFormat      [in]    字符PINBLOCK格式,标识使用ZPK加密PIN时的PIN数据块组成格式,
	*                                       详细参见PINBLOCK(字符)格式
	* @param    accountNum          [in]    参与ZPK密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                       1-24,当pinBlockFormat=2时不超过16个数字
	* @param    pinBlockCipher      [out]   ZPK加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverP0_GenerateSpecifyLengthRandomCharacterPIN(
		FRM_INT8_PTR pinLength,
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR* pinBlockCipher);
	/**
	* @brief    P6指令,ZPK加密字符PIN
	* @param    zpkIndexOrCipher    [in]    ZPK密钥索引或LMK加密的密文
	* @param    pinPlain            [in]    字符PIN明文
	* @param    pinBlockFormat      [in]    字符PINBLOCK格式,标识使用ZPK加密PIN时的PIN数据块组成格式,
	*                                       详细参见PINBLOCK(字符)格式
	* @param    accountNum          [in]    参与ZPK密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                       1-24,当pinBlockFormat=2时不超过16个数字
	* @param    pinBlockCipher      [out]   ZPK加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverP6_ZPKEncryptCharacterPIN(
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pinPlain,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR* pinBlockCipher);
	/**
	* @brief    P7指令,字符PINBLOCK转加密
	*           ZPK下加密的字符PIN密文,转换到其他密钥下加密,该指令不支持密钥分散.
	*           字符PIN包含字母和数字的组合:'0'-'9','A'-'Z','a'-'z'
	* @param    srcZpkIndexOrCipher     [in]    源ZPK密钥索引或LMK加密的密文
	* @param    dstKeyType              [in]    目标密钥类型,001:ZPK;002:TPK/PVK
	* @param    dstKeyIndexOrCipher     [in]    目标密钥索引或LMK加密的密文
	* @param    pinBlockCipherBySrcZpk  [in]    源PINBLOCK密文
	* @param    srcPinBlockFormat       [in]    源字符PINBLOCK格式,标识使用ZPK加密PIN时的PIN数据块组成格式,
	*                                           详细参见PINBLOCK(字符)格式
	* @param    srcAccountNum           [in]    参与源ZPK密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           1-24,当pinBlockCipherBySrcKey=2时不超过16个数字
	* @param    dstPinBlockFormat       [in]    目标字符PINBLOCK格式,标识使用ZPK加密PIN时的PIN数据块组成格式,
	*                                           详细参见PINBLOCK(字符)格式
	* @param    dstAccountNum           [in]    参与目标密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           1-24,当dstPinBlockFormat=2时不超过16个数字
	* @param    pinPlainLength          [out]   PIN明文长度
	* @param    pinBlockCipherByDstKey  [out]   目标密钥加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverP7_CharacterPINBLOCKCipherTransfer(
		FRM_INT8_PTR srcZpkIndexOrCipher,
		FRM_INT8_PTR dstKeyType,
		FRM_INT8_PTR dstKeyIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherBySrcZpk,
		FRM_INT8_PTR srcPinBlockFormat,
		FRM_INT8_PTR srcAccountNum,
		FRM_INT8_PTR dstPinBlockFormat,
		FRM_INT8_PTR dstAccountNum,
		FRM_INT8_PTR* pinPlainLength,
		FRM_INT8_PTR* pinBlockCipherByDstKey);
	/**
	* @brief    D7指令,数字PINBLOCK转加密,该指令支持源密钥/目的密钥的分散和会话密钥的产生,支持PINBLOCK格式和账号的变换
	* @param    srcZpkIndexOrCipher     [in]    源ZPK密钥索引或LMK加密的密文
	* @param    srcDiversifyFactor      [in]    源密钥分散因子(串联),每级8字节,最多3级
	* @param    srcSessionKeyGenMode    [in]    源密钥会话密钥产生模式,00-04
	* @param    srcSessionKeyFactor     [in]    源密钥会话密钥因子,2字节,一般为ATC,当srcSessionKeyGenMode值为01/02时有效
	* @param    dstZpkIndexOrCipher     [in]    目标ZPK密钥索引或LMK加密的密文
	* @param    dstDiversifyFactor      [in]    目标密钥分散因子(串联),每级8字节,最多3级
	* @param    dstSessionKeyGenMode    [in]    目标密钥会话密钥产生模式,00-04
	* @param    dstSessionKeyFactor     [in]    目标密钥会话密钥因子,2字节,一般为ATC,当dstSessionKeyGenMode值为01/02时有效
	* @param    pinBlockCipherBySrcZpk  [in]    源密钥加密的PINBLOCK密文
	* @param    srcPinBlockFormat       [in]    源密钥下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    srcAccountNum           [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           当srcPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    dstPinBlockFormat       [in]    源密钥下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    dstAccountNum           [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           当dstPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinBlockCipherByDstZpk  [out]   目标密钥加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverD7_NumberPINBLOCKCipherTransfer(
		FRM_INT8_PTR srcZpkIndexOrCipher,
		FRM_INT8_PTR srcDiversifyFactor,
		FRM_INT8_PTR srcSessionKeyGenMode,
		FRM_INT8_PTR srcSessionKeyFactor,
		FRM_INT8_PTR dstZpkIndexOrCipher,
		FRM_INT8_PTR dstDiversifyFactor,
		FRM_INT8_PTR dstSessionKeyGenMode,
		FRM_INT8_PTR dstSessionKeyFactor,
		FRM_INT8_PTR pinBlockCipherBySrcZpk,
		FRM_INT8_PTR srcPinBlockFormat,
		FRM_INT8_PTR srcAccountNum,
		FRM_INT8_PTR dstPinBlockFormat,
		FRM_INT8_PTR dstAccountNum,
		FRM_INT8_PTR* pinBlockCipherByDstZpk);
	/**
	* @brief    S7指令,数字PINBLOCK转加密,该指令支持ZPK密钥的分散
	* @param    srcKeyType              [in]    源密钥类型,如109/MDK
	* @param    srcKeyIndexOrCipher     [in]    源密钥索引或LMK加密的密文
	* @param    srcDiversifyFactor      [in]    源密钥分散因子,每级16字节,最多8级
	* @param    srcSessionKeyGenMode    [in]    源密钥会话密钥产生模式,00-05
	* @param    srcSessionKeyFactor     [in]    源密钥会话密钥因子,当srcSessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    dstKeyType              [in]    目标密钥类型,如109/MDK
	* @param    dstKeyIndexOrCipher     [in]    目标密钥索引或LMK加密的密文
	* @param    dstDiversifyFactor      [in]    目标密钥分散因子,每级16字节,最多8级
	* @param    dstSessionKeyGenMode    [in]    目标密钥会话密钥产生模式,00-05
	* @param    dstSessionKeyFactor     [in]    目标密钥会话密钥因子,当dstSessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    pinBlockCipherBySrcKey  [in]    源密钥加密的PINBLOCK密文
	* @param    srcPinBlockFormat       [in]    源密钥下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    srcAccountNum           [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           当srcPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    dstPinBlockFormat       [in]    源密钥下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    dstAccountNum           [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           当dstPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinBlockCipherByDstKey  [out]   目标密钥加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverS7_NumberPINBLOCKCipherTransfer_G(
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR srcDiversifyFactor,
		FRM_INT8_PTR srcSessionKeyGenMode,
		FRM_INT8_PTR srcSessionKeyFactor,
		FRM_INT8_PTR dstKeyType,
		FRM_INT8_PTR dstKeyIndexOrCipher,
		FRM_INT8_PTR dstDiversifyFactor,
		FRM_INT8_PTR dstSessionKeyGenMode,
		FRM_INT8_PTR dstSessionKeyFactor,
		FRM_INT8_PTR pinBlockCipherBySrcKey,
		FRM_INT8_PTR srcPinBlockFormat,
		FRM_INT8_PTR srcAccountNum,
		FRM_INT8_PTR dstPinBlockFormat,
		FRM_INT8_PTR dstAccountNum,
		FRM_INT8_PTR* pinBlockCipherByDstKey);
	/**
	* @brief    N5指令,将字符PIN由TPK加密转为公钥加密
	*           该指令支持字符类型的PIN密文转换.通常用于网银系统中用户PIN的密文转换.TPK加密PIN数据块时采用ECB模式.
	* @param    tpkIndexOrCipher            [in]    TPK密钥索引或LMK加密的密文
	* @param    pinBlockCipherByTpk         [in]    TPK加密的PINBLOCK密文
	* @param    pinBlockFormat              [in]    字符PINBLOCK格式,标识使用TPK加密PIN时的PIN数据块组成格式,
	*                                               详细参见PINBLOCK(字符)格式
	* @param    accountNum                  [in]    参与TPK密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                               1-24,当pinBlockFormat=2时不超过16个数字
	* @param    publicKeyFlag               [in]    公钥算法标识类型,01:RSA;07:SM2
	* @param    publicKeyDer                [in]    公钥ASN.1格式的DER编码数据,不支持索引
	* @param    publicKeyAuthData           [in]    公钥认证数据,0-128字节,当publicKeyIndexOrDer为外部传入的明文时启用
	* @param    publicKeyMac                [in]    公钥MAC数据,当publicKeyIndexOrDer为外部传入的明文时启用
	* @param    publicKeyEncryptPinFormat   [in]    公钥加密PIN组成格式,
	*                                               00:ID长度(2N)+ID码+PIN长度(2N)+PIN明文;
	*                                               01:PIN明文块;
	*                                               02:PIN长度(2N)+PIN明文+ID长度(2N)+ID码
	* @param    id                          [in]    ID码,仅当publicKeyEncryptPinFormat为0/2时存在,1-20字节
	* @param    publicKeyEncryptPadMode     [in]    公钥加密PIN数据块时采用的填充模式,仅当publicKeyFlag为01时存在,
	*                                               01:PKCS#1 v1.5填充方式;
	*                                               07:在PIN数据块前面补0x00,以使数据长度等于RSA密钥模长
	* @param    pinCipherByPublicKey        [out]   公钥加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverN5_TPKCharacterPINBLOCKCipherTransferToPublicKey(
		FRM_INT8_PTR tpkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherByTpk,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR publicKeyFlag,
		FRM_INT8_PTR publicKeyIndexOrDer,
		FRM_INT8_PTR publicKeyAuthData,
		FRM_INT8_PTR publicKeyMac,
		FRM_INT8_PTR publicKeyEncryptPinFormat,
		FRM_INT8_PTR id,
		FRM_INT8_PTR publicKeyEncryptPadMode,
		FRM_INT8_PTR* pinCipherByPublicKey);
	/**
	* @brief    N6指令,公钥加密的字符PIN密文转为ZPK加密
	*           该指令支持字符类型的PIN密文转换.通常用于网银系统中用户PIN的密文转换.
	*           ZPK加密PIN数据块时采用ECB模式.可选的,输出ZPK对私钥解密后的PIN数据块计算的MAC值
	* @param    publicKeyFlag               [in]    公钥算法标识类型,01:RSA;07:SM2
	* @param    privateKeyIndexOrCipher     [in]    私钥索引或LMK加密的私钥密文
	* @param    publicKeyEncryptPinFormat   [in]    公钥加密PIN组成格式,
	*                                               00:ID长度(2N)+ID码+PIN长度(2N)+PIN明文;
	*                                               01:PIN明文块;
	*                                               02:PIN长度(2N)+PIN明文+ID长度(2N)+ID码
	* @param    publicKeyEncryptPadMode     [in]    公钥加密PIN数据块时采用的填充模式,仅当publicKeyFlag为01时存在,
	*                                               01:PKCS#1 v1.5填充方式;
	*                                               07:在PIN数据块前面补0x00,以使数据长度等于RSA密钥模长
	* @param    zpkIndexOrCipher            [in]    ZPK密钥索引或LMK加密的密文
	* @param    pinBlockFormat              [in]    字符PINBLOCK格式,标识使用ZPK加密PIN时的PIN数据块组成格式,
	*                                               详细参见PINBLOCK(字符)格式
	* @param    accountNum                  [in]    参与TPK密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                               1-24,当pinBlockFormat=2时不超过16个数字
	* @param    pinCipherByPublicKey        [in]    公钥加密的PIN密文
	* @param    macMode                     [in]    可选域,为NULL时无效,MAC算法模式01/03,输出数据块MAC值(ZPK对解密后的PIN数据块计算MAC)
	* @param    macPadMode                  [in]    计算MAC前数据的填充模式,详见"填充模式"
	* @param    pinPlainLength              [out]   PIN明文长度
	* @param    pinBlockCipherByZpk         [out]   ZPK加密的PINBLOCK密文
	* @param    id                          [out]   ID,仅当publicKeyEncryptPinFormat为0/2时存在,1-20字节
	* @param    mac                         [out]   PIN数据的MAC值,MAC算法模式有效时输出8/16字节
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverN6_PublicKeyCharacterPINCipherTransferToZPK(
		FRM_INT8_PTR publicKeyFlag,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR publicKeyEncryptPinFormat,
		FRM_INT8_PTR publicKeyEncryptPadMode,
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR pinCipherByPublicKey,
		FRM_INT8_PTR macMode,
		FRM_INT8_PTR macPadMode,
		FRM_INT8_PTR* pinPlainLength,
		FRM_INT8_PTR* pinBlockCipherByZpk,
		FRM_INT8_PTR* id,
		FRM_INT8_PTR* mac);
	/**
	* @brief    N7指令,将数字PIN由TPK加密转为公钥加密
	*           该指令支持数字类型的PIN密文转换.通常用于网银系统中用户PIN的密文转换.TPK加密PIN数据块时采用ECB模式
	* @param    tpkIndexOrCipher            [in]    TPK密钥索引或LMK加密的密文
	* @param    pinBlockCipherByTpk         [in]    TPK加密的PINBLOCK密文
	* @param    tpkPinBlockFormat           [in]    PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    accountNum                  [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                               当tpkPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    publicKeyFlag               [in]    公钥算法标识类型,01:RSA;07:SM2
	* @param    publicKeyDer                [in]    公钥ASN.1格式的DER编码数据,不支持索引
	* @param    publicKeyAuthData           [in]    公钥认证数据,0-128字节,当publicKeyIndexOrDer为外部传入的明文时启用
	* @param    publicKeyMac                [in]    公钥MAC数据,当publicKeyIndexOrDer为外部传入的明文时启用
	* @param    publicKeyEncryptPinFormat   [in]    公钥加密PIN组成格式,
	*                                               00:ID长度(2N)+ID码+PIN长度(2N)+PIN明文;
	*                                               01:PIN明文块;
	*                                               10:PINBLOCK块
	* @param    publicKeyPinBlockFormat     [in]    公钥加密的PIN数据块的格式代码,参见PINBLOCK(数字)格式
	*                                               仅当publicKeyEncryptPinFormat=10时有效
	* @param    id                          [in]    ID码,仅当publicKeyEncryptPinFormat为0/2时存在,1-20字节
	* @param    publicKeyEncryptPadMode     [in]    公钥加密PIN数据块时采用的填充模式,仅当publicKeyFlag为01时存在,
	*                                               01:PKCS#1 v1.5填充方式;
	*                                               07:在PIN数据块前面补0x00,以使数据长度等于RSA密钥模长
	* @param    pinCipherByPublicKey        [out]   公钥加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverN7_TPKNumberPINBLOCKCipherTransferToPublicKey(
		FRM_INT8_PTR tpkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherByTpk,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR publicKeyFlag,
		FRM_INT8_PTR publicKeyIndexOrDer,
		FRM_INT8_PTR publicKeyAuthData,
		FRM_INT8_PTR publicKeyMac,
		FRM_INT8_PTR publicKeyEncryptPinFormat,
		FRM_INT8_PTR id,
		FRM_INT8_PTR publicKeyPinBlockFormat,
		FRM_INT8_PTR publicKeyEncryptPadMode,
		FRM_INT8_PTR* pinCipherByPublicKey);
	/**
	* @brief    N8指令,公钥加密的数字PIN密文转为ZPK加密
	*           该指令支持数字类型的PIN密文转换.通常用于网银系统中用户PIN的密文转换.ZPK加密PIN数据块时采用ECB模式
	* @param    publicKeyFlag               [in]    公钥算法标识类型,01:RSA;07:SM2
	* @param    privateKeyIndexOrCipher     [in]    私钥索引或LMK加密的私钥密文
	* @param    publicKeyEncryptPinFormat   [in]    公钥加密PIN组成格式,
	*                                               00:ID长度(2N)+ID码+PIN长度(2N)+PIN明文;
	*                                               01:PIN明文块;
	* @param    publicKeyEncryptPadMode     [in]    公钥加密PIN数据块时采用的填充模式,仅当publicKeyFlag为01时存在,
	*                                               01:PKCS#1 v1.5填充方式;
	*                                               07:在PIN数据块前面补0x00,以使数据长度等于RSA密钥模长
	* @param    zpkIndexOrCipher            [in]    ZPK密钥索引或LMK加密的密文
	* @param    pinBlockFormat              [in]    PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    accountNum                  [in]    参与ZPK密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                               当pinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinCipherByPublicKey        [in]    公钥加密的PIN密文
	* @param    pinPlainLength              [out]   PIN明文长度
	* @param    pinBlockCipherByZpk         [out]   ZPK加密的PINBLOCK密文
	* @param    id                          [out]   ID,仅当publicKeyEncryptPinFormat为0/2时存在,1-20字节
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverN8_PublicKeyNumberPINCipherTransferToZPK(
		FRM_INT8_PTR publicKeyFlag,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR publicKeyEncryptPinFormat,
		FRM_INT8_PTR publicKeyEncryptPadMode,
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR pinCipherByPublicKey,
		FRM_INT8_PTR* pinPlainLength,
		FRM_INT8_PTR* pinBlockCipherByZpk,
		FRM_INT8_PTR* id);
	/**
	* @brief    CB指令,将数字PIN从ZPK下加密转换到私有算法加密
	* @param    srcZpkIndexOrCipher         [in]    源ZPK密钥索引或LMK加密的密文
	* @param    dstKeyType                  [in]    目标密钥类型,001:ZPK;002:PVK
	* @param    dstKeyIndexOrCipher         [in]    目标密钥索引或LMK加密的密文
	* @param    pinBlockCipherBySrcZpk      [in]    源PINBLOCK密文
	* @param    srcPinBlockFormat           [in]    源PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    srcAccountNum               [in]    参与源ZPK密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                               当srcPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    privateAlg                  [in]    标识采用私有算法加密PIN的算法:
	*                                               02-浙商银行电话项目私有算法;
	*                                               03-山西农信 PINBLOCK 加密算法;
	*                                               04~99,预留(当前版本不支持)
	* @param    date                        [in]    日期privatePinEncryptAlg=01时有效,格式yyyymmdd
	* @param    pinBlockCipherByPrivateAlg  [out]   私有算法加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverCB_ZPKNumberPINBLOCKCipherTransferToPrivateAlgorithm(
		FRM_INT8_PTR srcZpkIndexOrCipher,
		FRM_INT8_PTR dstKeyType,
		FRM_INT8_PTR dstKeyIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherBySrcZpk,
		FRM_INT8_PTR srcPinBlockFormat,
		FRM_INT8_PTR srcAccountNum,
		FRM_INT8_PTR privateAlg,
		FRM_INT8_PTR date,
		FRM_INT8_PTR* pinPlainLength,
		FRM_INT8_PTR* pinBlockCipherByPrivateAlg);



	//-其他功能,2条指令
	/**
	* @brief    CR指令,产生随机数
	* @param    length      [in]    生成随机数的长度，0-2048字节
	* @param    randomNum   [out]   生成的随机数
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverCR_GenerateRandomNumber(
		FRM_INT8_PTR length,
		FRM_INT8_PTR* randomNum);
	/**
	* @brief    NP指令,获取密码机运行状态
	* @param    hsmSelfCheckState           [out]   设备自检状态,每位代表下面每项自检结果:1-正常,0-自检失败;
	*                                               0-设备主密钥是否OK,
	*                                               1-设备服务状态是否OK,
	*                                               2-7,预留
	* @param    maxSupportLinkNum           [out]   当前支持的最大连接数
	* @param    occupiedLinkNum             [out]   当前已被占用的连接数
	* @param    cpuUtilization              [out]   CPU利用率
	* @param    memoryUsage                 [out]   内存使用率
	* @param    businessVolumeAfterPowerOn  [out]   开机后业务数
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverNP_GetHSMRunningState(
		FRM_INT8_PTR* hsmSelfCheckState,
		FRM_INT8_PTR* maxSupportLinkNum,
		FRM_INT8_PTR* occupiedLinkNum,
		FRM_INT8_PTR* cpuUtilization,
		FRM_INT8_PTR* memoryUsage,
		FRM_INT8_PTR* businessVolumeAfterPowerOn);
	//-以上金融IC卡应用主机命令
	//-以下雷卡兼容(RACAL)主机命令
	//-工作密钥管理,14条指令
	/**
	* @brief    A0指令,产生工作密钥
	*
	* @param    keyType             [in]    生成密钥的类型标识
	* @param    symmAlgUnderLmk     [in]    生成密钥的算法标识
	* @param    zmkIndexOrCipher    [in]    ZMK密钥索引或密文(不需要输出ZMK密文则填NULL)
	* @param    symmAlgUnderZmk     [in]    在 ZMK 下加密的密钥密文标识,X/Y/P/L/R仅当zmkIndexOrCipher有效时启用
	* @param    storeIndex          [in]    生成密钥的存储索引,0-2048(为0时表示不存储到加密机内部)
	* @param    storeTag            [in]    密钥存储到加密机时的标签,0到16位字符(storeIndex为0时无效)
	* @param    keyCipherByLmk      [out]   输出生成的密钥在LMK下加密的密文
	* @param    keyCipherByZmk      [out]   输出生成的密钥在ZMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverA0_GenerateWorkKey(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCipherByZmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    A4指令,密文成份合成一个密钥
	*
	* @param    keyType         [in]    密钥类型
	* @param    symmAlg         [in]    算法标识
	* @param    compCipher      [in]    密文成分串联,格式参考指令KE
	* @param    keyCipherByLmk  [out]   输出生成的密钥在LMK下加密的密文
	* @param    keyCheckValue   [out]   输出生成的密钥的校验值
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverA4_CipherCompositionCompoundKey(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR compCipher,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    A6指令,导入ZMK加密的密钥,即ZMK加密的密钥转换为LMK下加密.
	*
	* @param    keyType                 [in]    指定工作密钥的密钥类型
	* @param    zmkIndexOrCipher        [in]    ZMK的索引或ZMK在LMK下加密的密文值
	* @param    keyCipherByZmk          [in]    由ZMK加密的密钥密文
	* @param    symmAlg                 [in]    在LMK下加密的算法标识,为NULL时使用cipherByZmk中的算法标识(cipherByZmk中的算法标识为X/Y时,此处可选U/T,其他情况下必须与cipherByZmk保持一致)
	* @param    storeIndex              [in]    生成密钥的存储索引,0-2048
	* @param    storeTag                [in]    密钥存储标签,0到16位
	* @param    keyCipherByLmk          [out]   输出工作密钥在LMK下加密的密文
	* @param    keyCheckValue           [out]   输出工作密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverA6_ImportKey(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR keyCipherByZmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    A8指令,密码机内密钥或LMK加密的密钥转换成ZMK下加密导出
	*
	* @param    keyType                 [in]    指定导出密钥的密钥类型属性
	* @param    zmkIndexOrCipher        [in]    ZMK的索引或在LMK下加密的密文值
	* @param    keyIndexOrCipherByLmk   [in]    被导出密钥的索引或在LMK下加密的密文值
	* @param    symmAlgUnderZmk         [in]    在ZMK下加密的算法标识,indexOrCipherByLmk为密文时此处可填NULL,
	*                                           此时使用indexOrCipherByLmk中的算法标识(indexOrCipherByLmk中的算法标识为U/T时,则转换为X/Y),
	*                                           indexOrCipherByLmk为索引时,此处不能是U/T
	* @param    keyCipherByZmk          [out]   输出密钥在ZMK下加密的密文
	* @param    keyCheckValue           [out]   输出密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverA8_ExportKey(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR keyIndexOrCipherByLmk,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR* keyCipherByZmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    IA指令,产生一个ZPK
	*
	* @param    zmkIndexOrCipher    [in]    ZMK索引或密文(不需要输出ZMK密文则填NULL)
	* @param    symmAlgUnderZmk     [in]    可选项,ZPK在ZMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,ZPK在LMK下的算法标识,symmAlgUnderZmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderZmk有效时启用
	* @param    zpkCipherByZmk      [out]   ZPK在ZMK下加密的密文
	* @param    zpkCipherByLmk      [out]   ZPK在LMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverIA_GenerateZPK(
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* zpkCipherByZmk,
		FRM_INT8_PTR* zpkCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    FA指令,ZPK从ZMK加密转换为LMK加密
	*
	* @param    zmkIndexOrCipher    [in]    ZMK索引或密文(不需要输出ZMK密文则填NULL)
	* @param    zpkCipherByZmk      [in]    ZMK加密的ZPK密文
	* @param    symmAlgUnderZmk     [in]    可选项,ZPK在ZMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,ZPK在LMK下的算法标识,symmAlgUnderZmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderZmk有效时启用
	* @param    zpkCipherByLmk      [out]   输出ZPK在LMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverFA_ZMKZPKCipherTransferToLMK(
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR zpkCipherByZmk,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* zpkCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    GC指令,ZPK从LMK加密转换为ZMK加密
	*
	* @param    zmkIndexOrCipher    [in]    ZMK索引或密文(不需要输出ZMK密文则填NULL)
	* @param    zpkCipherByLmk      [in]    LMK加密的ZPK密文
	* @param    symmAlgUnderZmk     [in]    可选项,ZPK在ZMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,ZPK在LMK下的算法标识,symmAlgUnderZmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderZmk有效时启用
	* @param    zpkCipherByZmk      [out]   输出ZPK在ZMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverGC_LMKZPKCipherTransferToZMK(
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR zpkCipherByLmk,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* zpkCipherByZmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    FI指令,产生一个ZEK/ZAK
	*
	* @param    keyType             [in]    密钥类型,0:ZEK,1:ZAK
	* @param    zmkIndexOrCipher    [in]    ZMK索引或密文(不需要输出ZMK密文则填NULL)
	* @param    symmAlgUnderZmk     [in]    可选项,密钥在ZMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,密钥在LMK下的算法标识,symmAlgUnderZmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderZmk有效时启用
	* @param    keyCipherByZmk      [out]   密钥在ZMK下加密的密文
	* @param    keyCipherByLmk      [out]   密钥在LMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverFI_GenerateZEK_ZAK(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* keyCipherByZmk,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    FK指令,ZEK/ZAK从ZMK加密转换为LMK加密
	*
	* @param    keyType             [in]    密钥类型,0:ZEK,1:ZAK
	* @param    zmkIndexOrCipher    [in]    ZMK索引或密文(不需要输出ZMK密文则填NULL)
	* @param    keyCipherByZmk      [in]    ZMK加密的密钥密文
	* @param    symmAlgUnderZmk     [in]    可选项,密钥在ZMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,密钥在LMK下的算法标识,symmAlgUnderZmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderZmk有效时启用
	* @param    keyCipherByLmk      [out]   输出密钥在LMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverFK_ZMKZEK_ZAKCipherTransferToLMK(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR keyCipherByZmk,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    FM指令,ZEK/ZAK从LMK加密转换为ZMK加密
	*
	* @param    keyType             [in]    密钥类型,0:ZEK,1:ZAK
	* @param    zmkIndexOrCipher    [in]    ZMK索引或密文(不需要输出ZMK密文则填NULL)
	* @param    keyCipherByLmk      [in]    LMK加密的密钥密文
	* @param    symmAlgUnderZmk     [in]    可选项,密钥在ZMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,密钥在LMK下的算法标识,symmAlgUnderZmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderZmk有效时启用
	* @param    keyCipherByZmk      [out]   输出密钥在ZMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverFM_LMKZEK_ZAKCipherTransferToZMK(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR keyCipherByLmk,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* keyCipherByZmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    HC指令,产生一个TMK/TPK/PVK
	*
	* @param    tmkIndexOrCipher    [in]    TMK索引或密文
	* @param    symmAlgUnderTmk     [in]    可选项,密钥在TMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,密钥在LMK下的算法标识,symmAlgUnderTmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderTmk有效时启用
	* @param    keyCipherByTmk      [out]   密钥在TMK下加密的密文
	* @param    keyCipherByLmk      [out]   密钥在LMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverHC_GenerateTMK_TPK_PVK(
		FRM_INT8_PTR tmkIndexOrCipher,
		FRM_INT8_PTR symmAlgUnderTmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* keyCipherByTmk,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    HA指令,产生一个TAK
	*
	* @param    tmkIndexOrCipher    [in]    TMK索引或密文
	* @param    symmAlgUnderTmk     [in]    可选项,TAK在TMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,TAK在LMK下的算法标识,symmAlgUnderTmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderTmk有效时启用
	* @param    takCipherByTmk      [out]   TAK在TMK下加密的密文
	* @param    takCipherByLmk      [out]   TAK在LMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverHA_GenerateTAK(
		FRM_INT8_PTR tmkIndexOrCipher,
		FRM_INT8_PTR symmAlgUnderTmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* takCipherByTmk,
		FRM_INT8_PTR* takCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    MI指令,将TAK从ZMK下加密转为LMK下加密
	*
	* @param    zmkIndexOrCipher    [in]    ZMK索引或密文(不需要输出ZMK密文则填NULL)
	* @param    takCipherByZmk      [in]    ZMK加密的TAK密文
	* @param    symmAlgUnderZmk     [in]    可选项,TAK在ZMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,TAK在LMK下的算法标识,symmAlgUnderZmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderZmk有效时启用
	* @param    takCipherByLmk      [out]   输出TAK在LMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverMI_ZMKTAKCipherTransferToLMK(
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR takCipherByZmk,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* takCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    BU指令,为LMK加密的密钥生成密钥校验值
	*
	* @param    keyType2H           [in]    标识加密密钥的LMK组
	*                                       00-LMK对04-05,01-LMK对06-07,02-LMK对14-15
	*                                       03-LMK对16-17,07-LMK对24-25,08-LMK对26-27
	*                                       09-LMK对28-29,0A-LMK对30-31,0B-LMK对32-33
	*                                       42-LMK对14-15的变种4,FF-使用位于分隔符之后的特定密钥类型
	* @param    keyLengthFlag       [in]    密钥长度标识,0:单倍长密钥(8字节),1:双倍长,2:三倍长,3:32字节AES,
	*                                       keyIndexOrCipher为索引时有效
	* @param    keyIndexOrCipher    [in]    LMK加密的密钥密文
	* @param    keyType             [in]    密钥类型,keyType2N为"FF"时有效
	* @param    symmAlgUnderZmk     [in]    可选项,密钥在ZMK下的算法标识
	* @param    symmAlgUnderLmk     [in]    可选项,密钥在LMK下的算法标识,symmAlgUnderZmk有效时启用
	* @param    keyCheckValueType   [in]    可选项,密钥校验值长度,0:16H的KCV,向后兼容,1:6H的KCV,symmAlgUnderZmk有效时启用
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverBU_GenerateKeyCheckValue(
		FRM_INT8_PTR keyType2H,
		FRM_INT8_PTR keyLengthFlag,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR symmAlgUnderZmk,
		FRM_INT8_PTR symmAlgUnderLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* keyCheckValue);
	//-消息认证(MAC运算),6条指令
	/**
	* @brief    MA指令,TAK计算数据MAC
	*           采用模式2的填充规则,MAC算法根据密钥算法和长度选择:
	*           TAK密钥为单长度SM1/AES/SM4,采用ISO9797-1 MAC算法1(全密钥CBC-MAC);
	*           TAK密钥为双长度3DES,采用ISO9797-1 MAC算法3.
	* @param    takIndexOrCipher    [in]    TAK索引或LMK加密的密文
	* @param    data                [in]    数据,0-4096字节
	* @param    mac                 [out]   MAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverMA_TAKCalculateDataMAC(
		FRM_INT8_PTR takIndexOrCipher,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* mac);
	/**
	* @brief    MC指令,TAK验证数据MAC
	*           采用模式2的填充规则,MAC算法根据密钥算法和长度选择:
	*           TAK密钥为单长度SM1/AES/SM4,采用ISO9797-1 MAC算法1(全密钥CBC-MAC);
	*           TAK密钥为双长度3DES,采用ISO9797-1 MAC算法3.
	* @param    takIndexOrCipher    [in]    TAK索引或LMK加密的密文
	* @param    mac                 [in]    MAC
	* @param    data                [in]    数据,0-4096字节
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverMC_TAKVerifyDataMAC(
		FRM_INT8_PTR takIndexOrCipher,
		FRM_INT8_PTR mac,
		FRM_INT8_PTR data);
	/**
	* @brief    MQ指令,ZAK计算数据MAC
	*           采用模式2的填充规则,MAC算法根据密钥算法和长度选择:
	*           ZAK密钥为单长度SM1/AES/SM4,采用ISO9797-1 MAC算法1(全密钥CBC-MAC);
	*           ZAK密钥为双长度3DES,采用ISO9797-1 MAC算法3.
	* @param    sequenceFlag        [in]    0:唯一块,1:第一块,2:中间块,3:最后一块
	* @param    zakIndexOrCipher    [in]    ZAK索引或LMK加密的密文
	* @param    iv                  [in]    ZAK索引或LMK加密的密文
	* @param    data                [in]    数据,0-4095字节
	* @param    mac                 [out]   MAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverMQ_ZAKCalculateDataMAC(
		FRM_INT8_PTR sequenceFlag,
		FRM_INT8_PTR zakIndexOrCipher,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* mac);
	/**
	* @brief    UQ指令,ZPK计算数据MAC
	*           用于银联应用系统中,在线分发ZPK时验证密钥的有效性.
	*           采用模式2的填充规则,MAC算法采用ISO9797-1规范的MAC算法1,
	*           即使用全密钥对PADDING后的数据进行CBC加密取最后一段密文作为 MAC值.
	* @param    sequenceFlag        [in]    0:唯一块,1:第一块,2:中间块,3:最后一块
	* @param    zakIndexOrCipher    [in]    ZAK索引或LMK加密的密文
	* @param    iv                  [in]    用于计算 MAC/TAC 的初始向量,仅当报文块标识为2/3时有此域;
	*                                       当密钥标识为X/U时,该域为16H;
	*                                       当密钥标识为R/P/L时,该域为32H
	* @param    data                [in]    数据,0-4095字节
	* @param    macLength           [in]    输出MAC长度0x01-0x10(即1-16,输入时需使用16进制)字节
	* @param    mac                 [out]   MAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverUQ_ZPKCalculateDataCBC_MAC(
		FRM_INT8_PTR sequenceFlag,
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR data,
		FRM_INT8_PTR macLength,
		FRM_INT8_PTR* mac);
	/**
	* @brief    MU指令,ZAK/TAK计算数据的CBC-MAC
	*           用于银联应用系统中,在线分发ZAK/TAK时验证密钥的有效性.
	*           采用模式2的填充规则,MAC算法采用ISO9797-1规范的MAC算法1,
	*           即使用全密钥对PADDING后的数据进行CBC加密取最后一段密文作为 MAC值.
	* @param    sequenceFlag        [in]    0:唯一块,1:第一块,2:中间块,3:最后一块
	* @param    keyType             [in]    密钥类型,0:TAK,1:ZAK
	* @param    keyLengthFlag       [in]    密钥长度标识,0:单倍长密钥(8字节),1:双倍长,2:三倍长,3:32字节AES,
	*                                       keyIndexOrCipher为索引时有效
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    iv                  [in]    密钥索引或LMK加密的密文
	* @param    data                [in]    数据,0-4096字节
	* @param    mac                 [out]   MAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverMU_ZAK_TAKCalculateDataCBC_MAC(
		FRM_INT8_PTR sequenceFlag,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyLengthFlag,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* mac);
	/**
	* @brief    MU指令,ZAK/TAK产生X9.9和X9.19的报文MAC
	*           采用模式2的填充规则,MAC算法根据密钥算法和长度选择:
	*           ZAK密钥为单长度SM1/AES/SM4,采用ISO9797-1 MAC算法1(全密钥CBC-MAC);
  *           ZAK密钥为双长度3DES,采用ISO9797-1 MAC算法3
	* @param    sequenceFlag        [in]    0:唯一块,1:第一块,2:中间块,3:最后一块
	* @param    keyType             [in]    密钥类型,0:TAK,1:ZAK
	* @param    keyLengthFlag       [in]    密钥长度标识,0:单倍长密钥(8字节),1:双倍长,2:三倍长,3:32字节AES,
	*                                       keyIndexOrCipher为索引时有效
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    iv                  [in]    密钥索引或LMK加密的密文
	* @param    data                [in]    数据,0-4096字节
	* @param    mac                 [out]   MAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverMS_ZAK_TAKCalculateX9_9_X9_19MAC(
		FRM_INT8_PTR sequenceFlag,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyLengthFlag,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* mac);
	//-PIN产生与加密,3条指令
	/**
	* @brief    JA指令,产生一个随机数字PIN码
	*           产生一个长度为4-12的随机数字PIN码,输出LMK03-05加密的PIN密文
	* @param    accountNum  [in]    用户主账号有效位的最右12个数字
	* @param    pinLength   [in]    待产生的随机PIN的长度,04-12,为NULL时默认4位
	* @param    pinCipher   [out]   LMK加密的PIN密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverJA_GenerateRandomPIN(
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR pinLength,
		FRM_INT8_PTR* pinCipher);
	/**
	* @brief    BA指令,LMK加密一个明文PIN码
	* @param    pinPlain    [in]    PIN明文左对齐,右边填充多个字符'F'
	* @param    pinPlain    [in]    PIN明文左对齐,右边填充多个字符'F'
	* @param    accountNum  [in]    用户主账号有效位的最右12个数字
	* @param    pinCipher   [out]   LMK加密的PIN密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverBA_LMKEncryptPIN(
		FRM_INT8_PTR pinPlain,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR* pinCipher);
	/**
	* @brief    NG指令,LMK解密PIN码
	* @param    accountNum  [in]    用户主账号有效位的最右12个数字
	* @param    pinCipher   [in]    LMK加密的PIN密文
	* @param    pinPlain    [out]   PIN明文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverNG_LMKDecryptPIN(
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR pinCipher,
		FRM_INT8_PTR* pinPlain);
	//-PIN密文转换,6条指令
	/**
	* @brief    JC指令,将PIN由TPK加密转换为LMK加密
	* @param    tpkIndexOrCipher    [in]    TPK密钥索引或LMK加密的密文
	* @param    pinBlockCipherByTpk [in]    TPK加密的PINBLOCK密文
	* @param    pinBlockFormat      [in]    PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    accountNum          [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                       当tpkPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinCipherByLmk      [out]   LMK加密的PIN密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverJC_TPKPINCipherTransferToLMK(
		FRM_INT8_PTR tpkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherByTpk,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR* pinCipherByLmk);
	/**
	* @brief    JE指令,将PIN由ZPK加密转换为LMK加密
	* @param    zpkIndexOrCipher    [in]    ZPK密钥索引或LMK加密的密文
	* @param    pinBlockCipherByZpk [in]    ZPK加密的PINBLOCK密文
	* @param    pinBlockFormat      [in]    PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    accountNum          [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                       当zpkPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinCipherByLmk      [out]   LMK加密的PIN密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverJE_ZPKPINCipherTransferToLMK(
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherByZpk,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR* pinCipherByLmk);
	/**
	* @brief    JG指令,将PIN由LMK加密转换为ZPK 加密
	* @param    zpkIndexOrCipher    [in]    ZPK密钥索引或LMK加密的密文
	* @param    pinBlockFormat      [in]    PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    accountNum          [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                       当zpkPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinCipherByLmk      [in]    LMK加密的PIN密文
	* @param    pinBlockCipherByZpk [out]   ZPK加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverJG_LMKPINCipherTransferToZPK(
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR pinCipherByLmk,
		FRM_INT8_PTR* pinBlockCipherByZpk);
	/**
	* @brief    CA指令,将PIN由TPK加密转换为ZPK加密
	* @param    tpkIndexOrCipher        [in]    TPK密钥索引或LMK加密的密文
	* @param    zpkIndexOrCipher        [in]    ZPK密钥索引或LMK加密的密文
	* @param    pinBlockCipherByTpk     [in]    TPK加密的PINBLOCK密文
	* @param    tpkPinBlockFormat       [in]    TPK下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    zpkPinBlockFormatIn     [in]    ZPK下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    accountNum              [in]    参与密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           当tpkPinBlockFormat/zpkPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinPlainLength          [out]   PIN明文长度
	* @param    pinBlockCipherByZpk     [out]   ZPK加密的PINBLOCK密文
	* @param    zpkPinBlockFormatOut    [out]   ZPK加密的PINBLOCK格式
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverCA_TPKPINCipherTransferToZPK(
		FRM_INT8_PTR tpkIndexOrCipher,
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherByTpk,
		FRM_INT8_PTR tpkPinBlockFormat,
		FRM_INT8_PTR zpkPinBlockFormatIn,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR* pinPlainLength,
		FRM_INT8_PTR* pinBlockCipherByZpk,
		FRM_INT8_PTR* zpkPinBlockFormatOut);
	/**
	* @brief    CC指令,将PIN由ZPK1加密转换为ZPK2加密
	* @param    srcZpkIndexOrCipher     [in]    源ZPK密钥索引或LMK加密的密文
	* @param    dstZpkIndexOrCipher     [in]    目标ZPK密钥索引或LMK加密的密文
	* @param    pinBlockCipherBySrcZpk  [in]    源ZPK加密的PINBLOCK密文
	* @param    srcZpkPinBlockFormat    [in]    源ZPK下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    dstZpkPinBlockFormatIn  [in]    ZPK下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    accountNum              [in]    参与密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           当tpkPinBlockFormat/zpkPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinPlainLength          [out]   PIN明文长度
	* @param    pinBlockCipherByDstZpk  [out]   目标ZPK加密的PINBLOCK密文
	* @param    dstZpkPinBlockFormatOut [out]   目标ZPK加密的PINBLOCK格式
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverCC_ZPKPINCipherTransferToZPK2(
		FRM_INT8_PTR srcZpkIndexOrCipher,
		FRM_INT8_PTR dstZpkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherBySrcZpk,
		FRM_INT8_PTR srcZpkPinBlockFormat,
		FRM_INT8_PTR dstZpkPinBlockFormatIn,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR* pinPlainLength,
		FRM_INT8_PTR* pinBlockCipherByDstZpk,
		FRM_INT8_PTR* dstZpkPinBlockFormatOut);
	/**
	* @brief    TI指令,将PIN由TPK1/ZPK1加密转换为TPK2/ZPK2加密
	* @param    srcKeyType              [in]    源密钥类型,1:TPK,2:ZPK
	* @param    srcKeyIndexOrCipher     [in]    源密钥索引或LMK加密的密文
	* @param    dstKeyType              [in]    目标密钥类型,1:TPK/PVK,2:ZPK
	* @param    dstKeyIndexOrCipher     [in]    目标密钥索引或LMK加密的密文
	* @param    pinBlockCipherBySrcKey  [in]    源密钥加密的PINBLOCK密文
	* @param    srcPinBlockFormat       [in]    源密钥下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    srcAccountNum           [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           当srcPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    dstPinBlockFormat       [in]    目标密钥下加密PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    dstAccountNum           [in]    参与目标密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                           当dstPinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    pinBlockCipherByDstKey  [out]   目标密钥加密的PINBLOCK密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTI_TPK1_ZPK1PINCipherTransferToTPK2_ZPK2(
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR dstKeyType,
		FRM_INT8_PTR dstKeyIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherBySrcKey,
		FRM_INT8_PTR srcPinBlockFormat,
		FRM_INT8_PTR srcAccountNum,
		FRM_INT8_PTR dstPinBlockFormat,
		FRM_INT8_PTR dstAccountNum,
		FRM_INT8_PTR* pinBlockCipherByDstKey);
	//-PIN验证,8条指令
	/**
	* @brief    DE指令,产生IBM PIN Offset
	* @param    pvkIndexOrCipher    [in]    PVK密钥索引或LMK加密的密文
	* @param    pinCipherByLmk      [in]    LMK加密的PIN密文
	* @param    minPinVerifyLength  [in]    最小的PIN校验长度
	* @param    accountNum          [in]    用户主账号去除校验位最右12个数字
	* @param    decConvertTable     [in]    转换16进制到10进制数的表
	* @param    pinVerifyData       [in]    用户定义的数据,包含11个16进制字符和1个字符N
	*                                       (向密码机指出在哪里插入帐号的最后5位)
	* @param    pinOffset           [out]   偏移量,左对齐,右边填充F
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverDE_GenerateIBMPINOffset(
		FRM_INT8_PTR pvkIndexOrCipher,
		FRM_INT8_PTR pinCipherByLmk,
		FRM_INT8_PTR minPinVerifyLength,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR decConvertTable,
		FRM_INT8_PTR pinVerifyData,
		FRM_INT8_PTR* pinOffset);
	/**
	* @brief    EE指令,使用IBM方式得到一个PIN
	* @param    pvkIndexOrCipher    [in]    PVK密钥索引或LMK加密的密文
	* @param    pinOffset           [in]    为NULL时默认值为"000000FFFFFF"(也可直接传入该值),
	*                                       该域包含offset(如果有offset的话),左对齐,右填充'F',
	* @param    minPinVerifyLength  [in]    最小的PIN校验长度
	* @param    accountNum          [in]    用户主账号去除校验位最右12个数字
	* @param    decConvertTable     [in]    转换16进制到10进制数的表
	* @param    pinVerifyData       [in]    用户定义的数据,包含11个16进制字符和1个字符N
	*                                       (向密码机指出在哪里插入帐号的最后5位)
	* @param    pinCipherByLmk      [out]   LMK加密的PIN密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEE_GeneratePINWithIBMMethod(
		FRM_INT8_PTR pvkIndexOrCipher,
		FRM_INT8_PTR pinOffset,
		FRM_INT8_PTR minPinVerifyLength,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR decConvertTable,
		FRM_INT8_PTR pinVerifyData,
		FRM_INT8_PTR* pinCipherByLmk);
	/**
	* @brief    DA指令,校验一个用IBM方式的终端PIN,使用IBM3624方式校验一个TPK加密的PINBLOCK
	* @param    tpkIndexOrCipher    [in]    TPK密钥索引或LMK加密的密文
	* @param    pvkIndexOrCipher    [in]    PVK密钥索引或LMK加密的密文,用于校验PINOFFSET
	* @param    pinBlockCipherByTpk [in]    TPK加密的PINBLOCK密文
	* @param    pinBlockFormat      [in]    PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    minPinVerifyLength  [in]    最小的PIN校验长度
	* @param    accountNum          [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                       当pinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    decConvertTable     [in]    转换16进制到10进制数的表
	* @param    pinVerifyData       [in]    用户定义的数据,包含11个16进制字符和1个字符N
	*                                       (向密码机指出在哪里插入帐号的最后5位)
	* @param    offset              [in]    待校验的PINOFFSET,为NULL时默认值为"000000FFFFFF"(也可直接传入该值),
	*                                       该域包含offset(如果有offset的话),左对齐,右填充'F',
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverDA_VerifyPINBLOCKCipherByTPKWithIBMPINOffset(
		FRM_INT8_PTR tpkIndexOrCipher,
		FRM_INT8_PTR pvkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherByTpk,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR minPinVerifyLength,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR decConvertTable,
		FRM_INT8_PTR pinVerifyData,
		FRM_INT8_PTR pinOffset);
	/**
	* @brief    EA指令,校验一个用IBM方式的交换PIN,使用IBM3624方式校验一个ZPK加密的PINBLOCK
	* @param    zpkIndexOrCipher    [in]    ZPK密钥索引或LMK加密的密文
	* @param    pvkIndexOrCipher    [in]    PVK密钥索引或LMK加密的密文,用于校验PINOFFSET
	* @param    pinBlockCipherByZpk [in]    ZPK加密的PINBLOCK密文
	* @param    pinBlockFormat      [in]    PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    minPinVerifyLength  [in]    最小的PIN校验长度
	* @param    accountNum          [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
	*                                       当pinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    decConvertTable     [in]    转换16进制到10进制数的表
	* @param    pinVerifyData       [in]    用户定义的数据,包含11个16进制字符和1个字符N
	*                                       (向密码机指出在哪里插入帐号的最后5位)
	* @param    pinOffset           [in]    待校验的PINOFFSET,为NULL时默认值为"000000FFFFFF"(也可直接传入该值),
	*                                       该域包含offset(如果有offset的话),左对齐,右填充'F',
	*
	* @return   成功返回0,否则返回非0
	*/

	FRM_INT32 STDCALL_ driverEA_VerifyPINBLOCKCipherByZPKWithIBMPINOffset(
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pvkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherByZpk,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR minPinVerifyLength,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR decConvertTable,
		FRM_INT8_PTR pinVerifyData,
		FRM_INT8_PTR pinOffset);
	/**
	* @brief    DG指令,产生VISA PVV,计算一个4位数字的VISA PVV,源PIN支持LMK加密的PIN密文形式
	* @param    pvkIndexOrCipher    [in]    PVK密钥索引或LMK加密的密文
	* @param    pinCipherByLmk      [in]    LMK加密的PIN密文
	* @param    accountNum          [in]    用户主账号去除校验位最右12个数字
	* @param    pvki                [in]    PVK标识,取值0-F
	* @param    pvv                 [out]   VISA PVV,4位数字
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverDG_GenerateVISA_PVV(
		FRM_INT8_PTR pvkIndexOrCipher,
		FRM_INT8_PTR pinCipherByLmk,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR pvki,
		FRM_INT8_PTR* pvv);

	/**
	* @brief    EC指令,PVV校验ZPK加密的PINBLOCK
	* @param    zpkIndexOrCipher    [in]    ZPK密钥索引或LMK加密的密文
	* @param    pvkIndexOrCipher    [in]    PVK密钥索引或LMK加密的密文
	* @param    pinBlockCipherByZpk [in]    ZPK加密的PINBLOCK密文
	* @param    pinBlockFormat      [in]    PIN数据块的格式代码,参见PINBLOCK(数字)格式
	* @param    accountNum          [in]    用户主账号去除校验位最右12个数字
	* @param    pvki                [in]    PVK标识,取值0-F
	* @param    pvv                 [in]    VISA PVV,4位数字
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEC_VerifyPINBLOCKCipherByZPKWithPVV(
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pvkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherByZpk,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR pvki,
		FRM_INT8_PTR pvv);
	/**
	* @brief    RY指令,生成或者校验美国运通的CSC
	* @param    modeIn                  [in]    模式:3,产生CSC;4,校验CSC
	* @param    cvkIndexOrCipher        [in]    PVK密钥索引或LMK加密的密文
	* @param    accountNum              [in]    账号的全部数字,如不足19位则左补0至19位
	* @param    expiryDate              [in]    4位卡过期时间(9301代表93年1月)
	* @param    csc5In                  [in]    5位的CSC,modeIn位4时有效,如果不存在输入"FFFFF"或NULL
	* @param    csc4In                  [in]    4位的CSC,modeIn位4时有效,如果不存在输入"FFFF"或NULL
	* @param    csc3In                  [in]    3位的CSC,modeIn位4时有效,如果不存在输入"FFF"或NULL
	* @param    modeOut                 [out]   模式,与modeIn一致
	* @param    csc5OutOrVerifyResult   [out]   5位的CSC(modeIn位3时)或
	*                                           5位CSC的校验结果(modeIn位4时,0:通过;1:输入不存在2:失败)
	* @param    csc4OutOrVerifyResult   [out]   4位的CSC(modeIn位3时)或
	*                                           4位CSC的校验结果(modeIn位4时,0:通过;1:输入不存在2:失败)
	* @param    csc3OutOrVerifyResult   [out]   3位的CSC(modeIn位3时)或
	*                                           3位CSC的校验结果(modeIn位4时,0:通过;1:输入不存在2:失败)
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverRY_Generate_VerifyAmericanExpressCSC(
		FRM_INT8_PTR modeIn,
		FRM_INT8_PTR cvkIndexOrCipher,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR expiryDate,
		FRM_INT8_PTR csc5In,
		FRM_INT8_PTR csc4In,
		FRM_INT8_PTR csc3In,
		FRM_INT8_PTR* modeOut,
		FRM_INT8_PTR* csc5OutOrVerifyResult,
		FRM_INT8_PTR* csc4OutOrVerifyResult,
		FRM_INT8_PTR* csc3OutOrVerifyResult);
	/**
   * @brief    DV指令,校验一个用IBM方式的交换PIN,使用IBM3624方式校验一个ZPK加密的PINBLOCK
   * @param    zpkIndexOrCipher    [in]    ZPK密钥索引或LMK加密的密文
   * @param    pvkIndexOrCipher    [in]    PVK密钥索引或LMK加密的密文,用于校验PINOFFSET
   * @param    pinBlockCipherByZpk [in]    ZPK加密的PINBLOCK密文
   * @param    pinBlockFormat      [in]    PIN数据块的格式代码,参见PINBLOCK(数字)格式
   * @param    minPinVerifyLength  [in]    最小的PIN校验长度
   * @param    accountNum          [in]    参与源密钥对PINBLOCK加密运算的帐号(不包含校验位),
   *                                       当pinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
   * @param    decConvertTable     [in]    转换16进制到10进制数的表
   * @param    pinVerifyData       [in]    用户定义的数据,包含11个16进制字符和1个字符N
   *                                       (向密码机指出在哪里插入帐号的最后5位)
   * @param    pinOffset           [in]    待校验的PINOFFSET,为NULL时默认值为"000000FFFFFF"(也可直接传入该值),
   *                                       该域包含offset(如果有offset的话),左对齐,右填充'F',
   *
   * @return   成功返回0,否则返回非0
   */

	FRM_INT32 STDCALL_ driverDV_VerifyPINBLOCKCipherByZPKTPKWithIBMPINOffset(
		FRM_INT8_PTR tpkzpkIndexOrCipher,
		FRM_INT8_PTR pvkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipherByZpk,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR minPinVerifyLength,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR decConvertTable,
		FRM_INT8_PTR pinVerifyData,
		FRM_INT8_PTR pinOffset);
	//-CVV计算,2条指令
	/**
	* @brief    CW指令,产生VISA CVV
	* @param    cvkIndexOrCvkA_B    [in]    CVK密钥索引或LMK下加密的VISA CVK A/B
	* @param    accountNum          [in]    卡片主账号
	* @param    expiryDate          [in]    4位卡过期时间(9301代表93年1月)
	* @param    serviceCode         [in]    服务吗
	* @param    cvv                 [Out]   3位CVV
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverCW_GenerateVISA_CVV(
		FRM_INT8_PTR cvkIndexOrCvkA_B,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR expiryDate,
		FRM_INT8_PTR serviceCode,
		FRM_INT8_PTR* cvv);
	/**
	* @brief    CY指令,校验VISA CVV
	* @param    cvkIndexOrCvkA_B    [in]    CVK密钥索引或LMK下加密的VISA CVK A/B
	* @param    cvv                 [in]    3位CVV
	* @param    accountNum          [in]    卡片主账号
	* @param    expiryDate          [in]    4位卡过期时间(9301代表93年1月)
	* @param    serviceCode         [in]    服务码
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverCY_VerifyVISA_CVV(
		FRM_INT8_PTR cvkIndexOrCvkA_B,
		FRM_INT8_PTR cvv,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR expiryDate,
		FRM_INT8_PTR serviceCode);
	//-数据加密解密运算,1条指令
	/**
	* @brief    E0指令,数据加解密
	* @param    sequenceFlag            [in]    0:唯一块,1:第一块,2:中间块,3:最后一块
	* @param    encryptOrDecryptFlag    [in]    运算标识,0:加密,1:解密
	* @param    algorithmMode           [in]    加解密时的运算模式,包括1/2/3/4即ECB/CBC/CFB/OFB
	* @param    keyIndexOrCipher        [in]    密钥索引或LMK加密的密文
	* @param    padMode                 [in]    Pad模式,仅当报文块标识为0或3时存在.
	*                                           0-如果数据长度为算法分组长度的整数倍,不填充,否则填充;
	*                                           1-不管数据长度是否为算法分组长度的整数倍,强制填充;
	*                                           填充字符由下一个域(padCharacter)定义,直到数据长度为算法分组长度的整数倍.
	* @param    padCharacter            [in]    Pad字符,仅当sequenceFlag为0或3时存在.
	* @param    padCountFlag            [in]    Pad计数标记,仅当sequenceFlag为0或3时存在.
	*                                           0:最后一个字节不是padding计数
	*                                           1:最后一个字节是padding计数,取值范围为0x01-0x10
	* @param    iv                      [in]    初始化向量,algorithmMode为2/3/4时有效
	* @param    dataIn                  [in]    数据,加密时0-1968字节,解密时0-1984字节
	* @param    dataOut                 [out]   加密后的密文或解密后的明文数据
	* @param    nextIv                  [out]   下一数据块的IV
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE0_DataEncryptDecrypt(
		FRM_INT8_PTR sequenceFlag,
		FRM_INT8_PTR encryptOrDecryptFlag,
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR padCharacter,
		FRM_INT8_PTR padCountFlag,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR dataIn,
		FRM_INT8_PTR* dataOut,
		FRM_INT8_PTR* nextIv);
	//-信函打印,9条指令
	/**
	* @brief    PA指令,将自定义的打印格式数据装载到HSM中
	*
	* @param    printFormatData [in]    打印格式符号表中定义的符号和常量
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverPA_LoadPrintFormatData(
		FRM_INT8_PTR printFormatData);
	/**
	* @brief    PE指令,打印PIN/PIN请求数据
	* @param    documentType        [in]    文档类型
	*                                       A:"two-up"格式中的第一个信封;
	*                                       B:"two-up"格式中的第二个信封;
	*                                       C:"one-up"格式
	* @param    accountNum          [in]    用户主账号去除校验位最右12个数字
	* @param    pinCipherByLmk      [in]    LMK加密的PIN密文
	* @param    printDomain         [in]    多个打印域串连,打印域之间用";"分割(首个域之前和最后域之后不允许有";")
	* @param    pinAndRefCheckValue [out]   13位PIN和请求参考数的检查值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverPE_PrintPIN_PINRequestEnvelop(
		FRM_INT8_PTR documentType,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR pinCipherByLmk,
		FRM_INT8_PTR printDomain,
		FRM_INT8_PTR* pinAndRefCheckValue);
	/**
	* @brief    NE指令,生成一个随机密钥,在LMK下加密,并按要求打印成份信函
	*           注:打印机必须连接到HSM打印端口.HSM必须有一个已定义的打印格式.
	*              对于一个单倍长度的密钥,密钥被分割成2个8字符长度的值.打印格式中的^P 和^Q分别标识左半和右半部分.
	*              对于一个双倍长度的密钥,打印格式中的^P 和^Q 分别标识第一和第二个密钥.
	*              对于一个三倍长度的密钥,打印格式中的^P、^Q和^R分别标识第一、第二和第三个密钥.
	*              打印格式中的^T标识密钥的校验值.
	* @param    keyType             [in]    生成密钥的类型标识
	* @param    symmAlg             [in]    生成密钥的算法标识
	* @param    printDomain         [in]    多个打印域串连,打印域之间用";"分割(首个域之前和最后域之后不允许有";")
	* @param    keyCipherByLmk      [out]   输出生成的密钥在LMK下加密的密文
	* @param    keyCheckValue       [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverNE_GenerateKeyPrintSeparateComposition(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR printDomain,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    A2指令,随机产生一个密钥成份,通过连接于密码机的打印机打印出明文,并返回成份的密文
	*           注:打印机必须连接到HSM打印端口.HSM必须有一个已定义的打印格式.
	* @param    keyType         [in]    生成成分的类型标识
	* @param    symmAlg         [in]    生成成分的算法标识
	* @param    printDomain     [in]    多个打印域串连,打印域之间用";"分割(首个域之前和最后域之后不允许有";")
	* @param    compCipherByLmk [out]   输出生成的成分在LMK下加密的密文
	* @param    compCheckValue  [out]   输出生成的成分的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverA2_GeneratePrintKeyComposition(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR printDomain,
		FRM_INT8_PTR* compCipherByLmk,
		FRM_INT8_PTR* compCheckValue);
	/**
	* @brief    A3指令,随机产生指定长度的密钥分量和分量的校验数据,按照PA设置的打印格式进行打印
	*           注:校验值在PA内使用^T 标识,沿用已有的规则
	* @param    generateMode            [in]    生成模式
	*                                           0:表示存在keyType和symmAlg字段
	*                                           1:表示存在compLength字段
	* @param    keyType                 [in]    生成成分的类型标识,generateMode为0时有效
	* @param    symmAlg                 [in]    生成成分的算法标识,generateMode为0时有效
	* @param    compLength              [in]    分量长度,16进制0x00-0x20(即0-32)字节generateMode为1时有效
	* @param    compCheckValueAlg       [in]    成分校验值算法标识:
	*                                           00:无格式,不打印校验值
	*                                           03:ISO 10118-2
	*                                           05:SHA-224, 06:SHA-256, 07:SHA-384
	*                                           08:SHA-512, 20:SM3-256
	*                                           30:加密一组全0数据得到校验值,当且仅当生成模式为generateMode为0时有效
	* @param    compCheckValueWay       [in]    成分校验值的取值方式:
	*                                           01-08:校验值的左1-8字节
	*                                           10:全部校验值的结果
	*                                           11-18:校验值的右1-8字节
	*                                           20:校验值左右异或
	* @param    printDomain             [in]    多个打印域串连,打印域之间用";"分割(首个域之前和最后域之后不允许有";")
	* @param    compPlainOrCipherByLmk  [out]   生成的成分在LMK下加密的密文(generateMode=0)或明文(generateMode=1)
	* @param    compCheckValue          [out]   成分的校验值,compCheckValueAlg不为0时存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverA3_GeneratePrintKeyCompositionAndCheckValue(
		FRM_INT8_PTR generateMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR compLength,
		FRM_INT8_PTR compCheckValueAlg,
		FRM_INT8_PTR compCheckValueWay,
		FRM_INT8_PTR printDomain,
		FRM_INT8_PTR* compPlainOrCipherByLmk,
		FRM_INT8_PTR* compCheckValue);
	/**
	* @brief    PG指令,验证PIN/PIN和请求信封密码
	* @param    accountNum          [in]    用户主账号去除校验位最右12个数字
	* @param    pinCipherByLmk      [in]    LMK加密的PIN密文
	* @param    pinAndRefCheckValue [in]    13位PIN和请求参考数的检查值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverPG_VerifyPIN_PINAndRequestEnvelopCode(
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR pinCipherByLmk,
		FRM_INT8_PTR pinAndRefCheckValue);
	/**
	* @brief    OA指令,打印一个PIN请求信函
	* @param    documentType    [in]    文档类型
	*                                   A:"two-up"格式中的第一个信封;
	*                                   B:"two-up"格式中的第二个信封;
	*                                   C:"one-up"格式
	* @param    accountNum      [in]    用户主账号去除校验位最右12个数字
	* @param    printDomain     [in]    多个打印域串连,打印域之间用";"分割(首个域之前和最后域之后不允许有";")
	* @param    refCheckValue   [out]   12位参考数检查值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverOA_PrintPINRequestEnvelop(
		FRM_INT8_PTR documentType,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR printDomain,
		FRM_INT8_PTR* refCheckValue);
	/**
	* @brief    RC指令,验证请求信封密码
	* @param    accountNum      [in]    用户主账号去除校验位最右12个数字
	* @param    refCheckValue   [in]    12位参考数检查值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverRC_VerifyRequestEnvelopCode(
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR refCheckValue);
	/**
	* @brief    NF指令,根据密钥成份密文打印密钥成份
	*
	* @param    keyType         [in]    密钥类型
	* @param    compCipherByLmk [in]   输出生成的成分在LMK下加密的密文
	* @param    printDomain     [in]    多个打印域串连,打印域之间用";"分割(首个域之前和最后域之后不允许有";")
	* @param    compCheckValue  [out]   输出生成的成分的校验值
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverNF_PrintKeyCompositionAccordingCipherByLMK(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR compCipherByLmk,
		FRM_INT8_PTR printDomain,
		FRM_INT8_PTR* compCheckValue);
	//-其他功能,2条指令
	/**
	* @brief    NC指令,获取密码机信息
	* @param    dmkCheckValue   [out]   DMK校验值
	* @param    hostSerVer      [out]   主机服务版本号
	* @param    manageSerVer    [out]   管理服务版本号
	* @param    cryptoModuleVer [out]   密码模块版本号
	* @param    deviceId        [out]   设备序列号
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverNC_GetHSMInformation(
		FRM_INT8_PTR* dmkCheckValue,
		FRM_INT8_PTR* hostSerVer,
		FRM_INT8_PTR* manageSerVer,
		FRM_INT8_PTR* cryptoModuleVer,
		FRM_INT8_PTR* deviceId);
	/**
	* @brief   GM指令,对一个数据块进行哈希运算
	*
	* @param    hashFlag        [in]    HASH算法模式标识:
	*                                   03:ISO 10118-2
	*                                   05:SHA-224, 06:SHA-256, 07:SHA-384
	*                                   08:SHA-512, 20:SM3-256
	* @param    data            [in]    数据,0-4096字节
	* @param    userId          [in]    用户ID,0-32字节,hashFlag为20(SM3-256)时有效,
	*                                   为NULL时表示不带ID的SM3算法或使用国密局默认ID:1234567812345678
	* @param    sm2PublicKey    [in]    SM2算法公钥,X||Y序列
	* @param    hash            [out]   HASH
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverGM_CalculateDataHASH(
		FRM_INT8_PTR hashFlag,
		FRM_INT8_PTR data,
		FRM_INT8_PTR userId,
		FRM_INT8_PTR sm2PublicKey,
		FRM_INT8_PTR* hash);
	//-以上雷卡兼容(RACAL)主机命令
	//-以下非对称应用主机命令
	//-RSA算法应用,16条指令
	/**
	* @brief    EI指令,随机产生一对指定模长和指数的 RSA 密钥对,输出公钥和LMK加密的私钥密文,支持内部存储模式
	*
	* @param    publicKeyLength         [in]    密钥模长1152-4096,必须为8的倍数
	* @param    publicKeyExponent       [in]    公钥指数,必须为奇数,为NULL时默认65537
	* @param    storeIndex              [in]    密码机存储索引1-64,为NULL时不存储
	* @param    storeTag                [in]    密码机存储标签0-16个字符,storeIndex有效时启用
	* @param    publicKeyDer            [out]   公钥,ASN.1 格式 DER 编码(模,指数序列)
	* @param    privateKeyCipherByLmk   [out]   LMK加密的私钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEI_GenerateRSAKeyPair(
		FRM_INT8_PTR publicKeyLength,
		FRM_INT8_PTR publicKeyExponent,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* publicKeyDer,
		FRM_INT8_PTR* privateKeyCipherByLmk);
	/**
	* @brief    EH指令,随机产生一对指定模长和指数的 RSA 密钥对,输出公钥和私钥各分量的明文
	*
	* @param    publicKeyLength     [in]    密钥模长1152-4096,必须为8的倍数
	* @param    publicKeyExponentIn [in]    公钥指数,必须为奇数,3或65537
	* @param    publicKey           [out]   公钥,长度为publicKeyLength/8
	* @param    publicKeyExponentOut[out]   公钥幂指数,3或65537
	* @param    privateKeyD         [out]   私钥d,长度为((publicKeyLength/8+1)/2)
	* @param    privateKeyP         [out]   私钥p,长度为((publicKeyLength/8+1)/2)
	* @param    privateKeyQ         [out]   私钥q,长度为((publicKeyLength/8+1)/2)
	* @param    privateKeyDp        [out]   私钥dp,长度为((publicKeyLength/8+1)/2)
	* @param    privateKeyDq        [out]   私钥dq,长度为((publicKeyLength/8+1)/2)
	* @param    privateKeyQinv      [out]   私钥qinv,长度为((publicKeyLength/8+1)/2)
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEH_GeneratePlainRSAKeyPair(
		FRM_INT8_PTR publicKeyLength,
		FRM_INT8_PTR publicKeyExponentIn,
		FRM_INT8_PTR* publicKey,
		FRM_INT8_PTR* publicKeyExponentOut,
		FRM_INT8_PTR* privateKeyD,
		FRM_INT8_PTR* privateKeyP,
		FRM_INT8_PTR* privateKeyQ,
		FRM_INT8_PTR* privateKeyDp,
		FRM_INT8_PTR* privateKeyDq,
		FRM_INT8_PTR* privateKeyQinv);
	/**
	* @brief    EK指令,装载 RSA 密钥对-兼容旧版本保留,建议使用 EJ 指令
	*
	* @param    storeIndex              [in]    存储索引1-64
	* @param    privateKeyCipherByLmk   [in]    LMK加密的私钥(包括 m,e,d 和 5 个 CRT 成份)
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEK_LoadRSAKeyPair_OldVersion_C(
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR privateKeyCipherByLmk);
	/**
	* @brief    EJ指令,LMK 加密的密文 RSA,导入到密码机内某索引中存储
	*
	* @param    privateKeyPassword      [in]    私钥口令,为NULL时不存在
	* @param    privateKeyCipherByLmk   [in]    私钥被LMK加密的密文
	* @param    storeIndex              [in]    存储索引1-64
	* @param    storeTag                [in]    存储加密机中的标签
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEJ_LoadRSAKeyPair(
		FRM_INT8_PTR privateKeyPassword,
		FRM_INT8_PTR privateKeyCipherByLmk,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag);
	/**
	* @brief    ER指令,获取密码机指定索引的 RSA 公钥
	*
	* @param    index       [in]    要获取的RSA公钥索引号
	* @param    publicKeyDer[out]   公钥的ANS.1格式的DER编码数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverER_GetRSAPublicKey(
		FRM_INT8_PTR index,
		FRM_INT8_PTR* publicKeyDer);
	/**
	* @brief   3A指令,使用RSA公钥加密数据,支持PKCS#1 v1.5版本的数据填充方式
	*
	* @param    padMode             [in]    RSA加密时的数据填充模式,可选00/01/02,即不填充/PKCS# V1.5方法填充/OAEP填充
	* @param    mgfHashAlgorithm    [in]    mgf杂凑算法,01/02/05/06/07/08,即SHA1/MD5/SHA224/SHA256/SHA384/SHA512,
	*                                       padMode为02时有效
	* @param    oaepParameter       [in]    OAEP编码参数,参照PKCS#1 v2.0第11.2.1节编码.HSM不解释和验证该内容.
	*                                       padMode为02时有效
	* @param    plain               [in]    待加密数据原文
	* @param    publicKeyIndexOrDer [in]    RSA公钥索引或ASN.1格式的DER编码数据
	* @param    cipher              [out]   加密后的密文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driver3A_RSAPublicKeyEncrypt(
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR mgfHashAlgorithm,
		FRM_INT8_PTR oaepParameter,
		FRM_INT8_PTR plain,
		FRM_INT8_PTR publicKeyIndexOrDer,
		FRM_INT8_PTR* cipher);
	/**
	* @brief   3B指令,使用RSA私钥解密数据,支持PKCS#1 v1.5版本的数据填充方式
	*
	* @param    padMode                 [in]    RSA加密时的数据填充模式,可选00/01/02,即不填充/PKCS# V1.5方法填充/OAEP填充
	* @param    mgfHashAlgorithm        [in]    mgf杂凑算法,01/02/05/06/07/08,即SHA1/MD5/SHA224/SHA256/SHA384/SHA512,
	*                                           padMode为02时有效
	* @param    oaepParameter           [in]    OAEP编码参数,参照PKCS#1 v2.0第11.2.1节编码.HSM不解释和验证该内容.
	*                                           padMode为02时有效
	* @param    cipher                  [in]    待解密数据密文
	* @param    privateKeyIndexOrCipher [in]    RSA私钥索引或LMK加密的私钥密文
	* @param    plain                   [out]   解密后的数据明文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driver3B_RSAPrivateKeyDecrypt(
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR mgfHashAlgorithm,
		FRM_INT8_PTR oaepParameter,
		FRM_INT8_PTR cipher,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR* plain);
	/**
	* @brief    EW指令,使用 RSA 私钥计算数据的签名值
	*
	* @param    hashAlgorithm           [in]    HASH算法标识,可选01-08,即ISO10118-2/NoHash/SHA-224/SHA256/SHA384/SHA512
	* @param    padMode                 [in]    RSA加密时的数据填充模式,可选00/01/02/03,即不填充/PKCS# V1.5方法填充/OAEP填充/PSS(EMSA-PSS-ENCODE)
	* @param    mgfHashAlgorithm        [in]    mgf杂凑算法,01/02/05/06/07/08,即SHA1/MD5/SHA224/SHA256/SHA384/SHA512,
	*                                           padMode为02或03时有效
	* @param    oaepParameter           [in]    OAEP编码参数,参照PKCS#1 v2.0第11.2.1节编码.HSM不解释和验证该内容.
	*                                           padMode为02时有效
	* @param    pssSaltLength           [in]    PSS SALT长度,00-FF(长度不能大于密钥模长-Hash,建议值Hash算法长度)
	*                                           padMode为03时有效
	* @param    data                    [in]    待签名数据
	* @param    privateKeyIndexOrCipher [in]    RSA私钥索引或LMK加密的私钥密文
	* @param    signature               [out]   数据的签名
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEW_RSAPrivateKeySign(
		FRM_INT8_PTR hashAlgorithm,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR mgfHashAlgorithm,
		FRM_INT8_PTR oaepParameter,
		FRM_INT8_PTR pssSaltLength,
		FRM_INT8_PTR data,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR* signature);
	/**
	* @brief    EY指令,使用 RSA 公钥验证数据的签名值
	*
	* @param    hashAlgorithm       [in]    HASH算法标识,可选01-08,即ISO10118-2/NoHash/SHA-224/SHA256/SHA384/SHA512
	* @param    padMode             [in]    RSA加密时的数据填充模式,可选00/01/02,即不填充/PKCS# V1.5方法填充/OAEP填充/PSS(EMSA-PSS-ENCODE)
	* @param    mgfHashAlgorithm    [in]    mgf杂凑算法,01/02/05/06/07/08,即SHA1/MD5/SHA224/SHA256/SHA384/SHA512,
	*                                       padMode为02时有效
	* @param    oaepParameter       [in]    OAEP编码参数,参照PKCS#1 v2.0第11.2.1节编码.HSM不解释和验证该内容.
	*                                       padMode为02时有效
	* @param    pssSaltLength       [in]    PSS SALT长度,00-FF(长度不能大于密钥模长-Hash,建议值Hash算法长度)
	*                                       padMode为03时有效
	* @param    signature           [in]    待验证签名
	* @param    publicKeyIndexOrDer [in]    RSA公钥索引或ASN.1格式的DER编码数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEY_RSAPublicKeyVerify(
		FRM_INT8_PTR hashAlgorithm,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR mgfHashAlgorithm,
		FRM_INT8_PTR oaepParameter,
		FRM_INT8_PTR pssSaltLength,
		FRM_INT8_PTR data,
		FRM_INT8_PTR signature,
		FRM_INT8_PTR publicKeyIndexOrDer);
	/**
	* @brief    EW扩展指令,使用 RSA 私钥计算数据的签名值扩展接口
	*
	* @param    hashAlgorithm           [in]    HASH算法标识,可选01-08,即ISO10118-2/NoHash/SHA-224/SHA256/SHA384/SHA512
	* @param    padMode                 [in]    RSA加密时的数据填充模式,可选00/01/04/07,即不填充/PKCS# V1.5方法填充/PSS/PKCS1.5裸签
	* @param    mgfHashAlgorithm        [in]    mgf杂凑算法,01/02/05/06/07/08,即SHA1/MD5/SHA224/SHA256/SHA384/SHA512,
	*                                           padMode为04有效
	* @param    pssSaltLength           [in]    PSS SALT长度,00-FF(长度不能大于密钥模长-Hash,建议值Hash算法长度)
	*                                           padMode为04时有效
	* @param    data                    [in]    待签名数据
	* @param    privateKeyIndexOrCipher [in]    RSA私钥索引或LMK加密的私钥密文
	* @param    signature               [out]   数据的签名
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEW_RSAPrivateKeySign_V1(
		FRM_INT8_PTR hashAlgorithm,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR mgfHashAlgorithm,
		FRM_INT8_PTR pssSaltLength,
		FRM_INT8_PTR data,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR* signature);
	/**
	* @brief    EY扩展指令,使用 RSA 公钥验证数据的签名值扩展接口
	*
	* @param    hashAlgorithm       [in]    HASH算法标识,可选01-08,即ISO10118-2/NoHash/SHA-224/SHA256/SHA384/SHA512
	* @param    padMode             [in]    RSA加密时的数据填充模式,可选00/01/04/07,即不填充/PKCS# V1.5方法填充/PSS/PKCS1.5裸签
	* @param    mgfHashAlgorithm    [in]    mgf杂凑算法,01/02/05/06/07/08,即SHA1/MD5/SHA224/SHA256/SHA384/SHA512,
	*                                       padMode为04时有效
	* @param    pssSaltLength       [in]    PSS SALT长度,00-FF(长度不能大于密钥模长-Hash,建议值Hash算法长度)
	*                                       padMode为04时有效
	* @param    data                [in]    待验签数据
	* @param    signature           [in]    待验证签名
	* @param    publicKeyIndexOrDer [in]    RSA公钥索引或ASN.1格式的DER编码数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEY_RSAPublicKeyVerify_V1(
		FRM_INT8_PTR hashAlgorithm,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR mgfHashAlgorithm,
		FRM_INT8_PTR pssSaltLength,
		FRM_INT8_PTR data,
		FRM_INT8_PTR signature,
		FRM_INT8_PTR publicKeyIndexOrDer);
	/**
	* @brief   指令TR,保护密钥(对称)加密导出一对 RSA 密钥
	*
	* @param    algorithmMode           [in]    加密时的运算模式,限00/01
	* @param    symmKeyType             [in]    保护密钥类型,限000/109或KEK/MDK
	* @param    symmKeyIndexOrCipher    [in]    保护密钥索引或密文
	* @param    symmKeyDiversifyFactor  [in]    保护密钥分散因子,每级16字节,最多8级
	* @param    privateKeyIndexOrCipher [in]    被导出RSA密钥对的索引或在LMK下加密的私钥密文
	* @param    padMode                 [in]    被导出的各私钥分量的填充规则00-10或10-11,
	*                                           为NULL时采用填充模式 01、明文DER编码格式输出公钥和一个分组全00的IV(CBC加密模式)
	* @param    outFormat               [in]    PAD标识不为NULL时有效,
	*                                           输出格式 0: 公钥明文DER; 1: m及e分量密文形式输出; 2: 公钥明文DER,私钥密文输出
	* @param    iv                      [in]    加密算法为01/CBC且PAD标识不为NULL时有效,长度为密钥算法的分组长度
	* @param    publicKeyDer            [out]   仅当padMode为NULL,或outFormat取值为0或2时存在;公钥ASN.1格式DER编码(模,指数序列)
	* @param    publicKeyM              [out]   仅当padMode不为NULL,且outFormat取值为1时存在公钥模m密文
	* @param    publicKeyE              [out]   仅当padMode不为NULL,且outFormat取值为1时存在公钥指数e密文
	* @param    privateKeyD             [out]   仅当padMode为NULL,或outFormat取值为0或1时存在私钥指数d密文
	* @param    privateKeyP             [out]   仅当padMode为NULL,或outFormat取值为0或1时存在私钥分量p密文
	* @param    privateKeyQ             [out]   仅当padMode为NULL,或outFormat取值为0或1时存在私钥分量p密文
	* @param    privateKeyDp            [out]   仅当padMode为NULL,或outFormat取值为0或1时存在私钥分量dp密文
	* @param    privateKeyDq            [out]   仅当padMode为NULL,或outFormat取值为0或1时存在私钥分量dp密文
	* @param    privateKeyQinv          [out]   仅当padMode为NULL,或outFormat取值为0或1时存在私钥分量dinv密文
	* @param    privateKeyCipherDer     [out]   仅当padMode不为NULL,且outFormat取值为2时存在私钥密文DER编码
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTR_SymmetricProtectKeyExportRSAKeyPair(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmKeyIndexOrCipher,
		FRM_INT8_PTR symmKeyDiversifyFactor,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR outFormat,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* publicKeyDer,
		FRM_INT8_PTR* publicKeyM,
		FRM_INT8_PTR* publicKeyE,
		FRM_INT8_PTR* privateKeyD,
		FRM_INT8_PTR* privateKeyP,
		FRM_INT8_PTR* privateKeyQ,
		FRM_INT8_PTR* privateKeyDp,
		FRM_INT8_PTR* privateKeyDq,
		FRM_INT8_PTR* privateKeyQinv,
		FRM_INT8_PTR* privateKeyCipherDer);
	/**
	* @brief    指令TS,保护密钥(对称)加密导入一对 RSA 密钥
	*
	* @param    algorithmMode           [in]    加密时的运算模式,限00/01
	* @param    symmKeyType             [in]    保护密钥类型,限000/109或KEK/MDK
	* @param    symmKeyIndexOrCipher    [in]    保护密钥索引或密文
	* @param    symmKeyDiversifyFactor  [in]    保护密钥分散级数,每级16字节,最多8级
	* @param    storeIndex              [in]    被导入密钥存储索引,1-64,为NULL时不存储到加密机
	* @param    storeTag                [in]    被导入密钥存储标签,0-16个字符,storeIndex有效时启用
	* @param    publicKeyDer            [in]    公钥ASN.1格式DER编码(模,指数序列)
	* @param    privateKeyD             [in]    私钥指数d密文
	* @param    privateKeyP             [in]    私钥分量p密文
	* @param    privateKeyQ             [in]    私钥分量p密文
	* @param    privateKeyDp            [in]    私钥分量dp密文
	* @param    privateKeyDq            [in]    私钥分量dp密文
	* @param    privateKeyQinv          [in]    私钥分量dinv密文
	* @param    privateKeyCipherByLmk   [out]   LMK加密的私钥密文DER编码
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTS_SymmetricProtectKeyImportRSAKeyPair(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmKeyIndexOrCipher,
		FRM_INT8_PTR symmKeyDiversifyFactor,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR publicKeyDer,
		FRM_INT8_PTR privateKeyD,
		FRM_INT8_PTR privateKeyP,
		FRM_INT8_PTR privateKeyQ,
		FRM_INT8_PTR privateKeyDp,
		FRM_INT8_PTR privateKeyDq,
		FRM_INT8_PTR privateKeyQinv,
		FRM_INT8_PTR* privateKeyCipherByLmk);
	/**
	* @brief    指令TV,RSA公钥加密导出一条对称密钥
	*
	* @param    symmKeyType             [in]    被导出对称密钥类型,限000/00A/109或KEK/DEK/MDK
	* @param    symmKeyIndexOrCipher    [in]    被导出对称密钥索引或密文
	* @param    diversifyFactor         [in]    被导出对称密钥分散因子,每级16字节,最多8级
	* @param    publicKeyIndexOrDer     [in]    RSA公钥索引或ASN.1格式的DER编码数据
	* @param    publicKeyAuthData       [in]    RSA公钥认证数据,0-128字节,当publicKeyIndexOrPlain为外部传入的明文时启用
	* @param    publicKeyMac            [in]    RSA公钥MAC数据,当publicKeyIndexOrPlain为外部传入的明文时启用
	* @param    keyCipherByPublic       [out]   RSA公钥加密的工作密钥(或子密钥)密文数据
	* @param    keyCheckValue           [out]   导出密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTV_RSAPublicKeyExportSymmetricKey(
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmKeyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR publicKeyIndexOrDer,
		FRM_INT8_PTR publicKeyAuthData,
		FRM_INT8_PTR publicKeyMac,
		FRM_INT8_PTR* keyCipherByPublic,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    指令TW,RSA 公钥保护导入一条对称密钥
	*
	* @param    symmKeyType             [in]    被导入对称密钥的类型,限000/00A/109或KEK/DEK/MDK
	* @param    symmAlg                 [in]    被导入对称密钥的算法标识,如X/DES2
	* @param    symmKeyCipherByPublic   [in]    被导入对称密钥的公钥加密密文
	* @param    symmKeyCheckValue       [in]    被导入对称密钥的校验值,全0或NULL则不校验
	* @param    storeIndex              [in]    被导入对称密钥存储索引,1-2048,为NULL时不存储到加密机
	* @param    storeTag                [in]    被导入对称密钥存储标签,0-16个字符,storeIndex有效时启用
	* @param    privateKeyIndexOrCipher [in]    保护公钥对应的撕咬索引或在LMK下加密的密文
	* @param    keyCipherByLmk          [out]   LMK加密的工作密钥(或子密钥)密文数据
	* @param    keyCheckValue           [out]   导入密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTW_RSAPublicKeyImportSymmetricKey(
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR symmKeyCipherByPublic,
		FRM_INT8_PTR symmKeyCheckValue,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    GI指令,RSA 公钥保护导入一条对称密钥, RACAL 兼容
	*
	* @param    padMode                 [in]    RSA加密时的数据填充模式,可选01/02,即PKCS# V1.5方法填充/OAEP填充
	* @param    mgfHashAlgorithm        [in]    mgf杂凑算法,01/02/05/06/07/08,即SHA1/MD5/SHA224/SHA256/SHA384/SHA512,
	*                                           padMode为02时有效
	* @param    oaepParameter           [in]    OAEP编码参数,参照PKCS#1 v2.0第11.2.1节编码.HSM不解释和验证该内容.
	*                                           padMode为02时有效
	* @param    symmKeyType4N           [in]    4位数字指示需要的LMK对,包含LMK变种.
	*                                           前2个数字表示用来加密密钥的LMK组号,后2个数字表示LMK变种,
	*                                           如ZMK:0400； HMAC KEY:3401
	* @param    symmKeyCipherByPublic   [in]    被导入对称密钥的公钥加密密文
	* @param    privateKeyIndexOrCipher [in]    RSA私钥索引或LMK加密的私钥密文
	* @param    keySolutionZmk          [in]    预留项,无意义
	* @param    keySolutionLmk          [in]    可选项,LMK下加密密钥的方案
	* @param    keyCheckValueType       [in]    可选项,keySolution不为NULL时有效,
	*                                           密钥校验值计算方式: 0,16H的KCV,向后兼容;1,6H的KCV
	* @param    initValue               [out]   对对称密钥的初始化值IV
	* @param    keyCipherByLmk          [out]   RSA公钥加密的工作密钥(或子密钥)密文数据
	* @param    keyCheckValue           [out]   导入密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverGI_RSAPublicKeyImportSymmetricKey_RACAL_C(
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR mgfHashAlgorithm,
		FRM_INT8_PTR oaepParameter,
		FRM_INT8_PTR symmKeyType4N,
		FRM_INT8_PTR symmKeyCipherByPublic,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR keySolutionZmk,
		FRM_INT8_PTR keySolutionLmk,
		FRM_INT8_PTR keyCheckValueType,
		FRM_INT8_PTR* initValue,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    GK指令,RSA 公钥保护导出一条对称密钥, RACAL 兼容
	*
	* @param    padMode             [in]    RSA加密时的数据填充模式,可选01/02,即PKCS# V1.5方法填充/OAEP填充
	* @param    mgfHashAlgorithm    [in]    mgf杂凑算法,01/02/05/06/07/08,即SHA1/MD5/SHA224/SHA256/SHA384/SHA512,
	*                                       padMode为02时有效
	* @param    oaepParameter       [in]    OAEP编码参数,参照PKCS#1 v2.0第11.2.1节编码.HSM不解释和验证该内容.
	*                                       padMode为02时有效
	* @param    symmKeyType4N       [in]    被导出对称密钥的类型
	* @param    symmKeyCipherByLmk  [in]    被导出对称密钥的索引或密文
	* @param    symmKeyCheckValue   [in]    被导出对称密钥的校验值,不满8字节则右补0,全0则不校验
	* @param    publicKeyMac        [in]    RSA公钥MAC数据
	* @param    publicKeyDer        [in]    RSA公钥ASN.1格式的DER编码数据
	* @param    publicKeyAuthData   [in]    RSA公钥认证数据,0-128字节
	* @param    initValue           [out]   对对称密钥的初始化值IV
	* @param    keyCipherByPublic   [out]   RSA公钥加密的工作密钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverGK_RSAPublicKeyExportSymmetricKey_RACAL_C(
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR mgfHashAlgorithm,
		FRM_INT8_PTR oaepParameter,
		FRM_INT8_PTR symmKeyType4N,
		FRM_INT8_PTR symmKeyCipherByLmk,
		FRM_INT8_PTR symmKeyCheckValue,
		FRM_INT8_PTR publicKeyMac,
		FRM_INT8_PTR publicKeyDer,
		FRM_INT8_PTR publicKeyAuthData,
		FRM_INT8_PTR* initValue,
		FRM_INT8_PTR* keyCipherByPublic);
	/**
	* @brief    指令EO, 对外部送入的RSA公钥计算认证MAC
	*
	* @param    publicKeyDerIn      [in]    RSA公钥ASN.1格式的DER编码数据
	* @param    authenticateData    [in]    认证数据,0-128字节,用于计算MAC的附加认证数据,由‘;’之外的任意可见字符组成
	* @param    mac                 [out]   公钥的认证MAC数据
	* @param    publicKeyDerOut     [out]   RSA公钥ASN.1格式的DER编码数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEO_GenerateRSAPublicKeyMAC(
		FRM_INT8_PTR publicKeyDerIn,
		FRM_INT8_PTR authenticateData,
		FRM_INT8_PTR* mac,
		FRM_INT8_PTR* publicKeyDerOut);
	//-SM2算法应用,22条指令
	/**
	* @brief    E7指令,产生指定曲线的SM2密钥对,可选的存储到密码机内某索引中
	*
	* @param    storeIndex              [in]    被导入密钥存储索引,1-64,为NULL时不存储到加密机
	* @param    storeTag                [in]    被导入密钥存储标签,0-16个字符,storeIndex有效时启用
	* @param    publicKeyDer            [out]   公钥,ASN.1 格式 DER 编码(模,指数序列)
	* @param    privateKeyCipherByLmk   [out]   LMK加密的私钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE7_GenerateSM2KeyPair(
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* publicKeyDer,
		FRM_INT8_PTR* privateKeyCipherByLmk);
	/**
	* @brief    E8指令,产生指定曲线的SM2密钥对, 输出公钥和私钥各分量的明文
	*
	* @param    publicKeyX  [out]   公钥x
	* @param    publicKeyY  [out]   公钥y
	* @param    privateKeyD [out]   私钥d
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE8_GeneratePlainSM2KeyPair(
		FRM_INT8_PTR* publicKeyX,
		FRM_INT8_PTR* publicKeyY,
		FRM_INT8_PTR* privateKeyD);
	/**
	* @brief    E1指令,将 SM2 明文公钥和 LMK 加密的密文私钥,导入到密码机内某索引中存储
	*
	* @param    publicKeyDer            [in]    公钥ASN.1的DER格式编码
	* @param    privateKeyCipherByLmk   [in]    私钥被LMK加密的密文
	* @param    storeIndex              [in]    被导入密钥存储索引,1-64,为NULL时不存储到加密机
	* @param    storeTag                [in]    被导入密钥存储标签,0-16个字符,storeIndex有效时启用
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE1_LoadSM2KeyPair(
		FRM_INT8_PTR publicKeyDer,
		FRM_INT8_PTR privateKeyCipherByLmk,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag);
	/**
	* @brief    E2指令,获取密码机内指定索引的 SM2 公钥
	*
	* @param    index           [in]    要获取的SM2公钥索引号
	* @param    publicKeyDer    [in]    输出获取到的公钥的ANS.1格式的DER编码数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE2_GetSM2PublicKey(
		FRM_INT8_PTR index,
		FRM_INT8_PTR* publicKeyDer);
	/**
	* @brief    指令E3,使用SM2公钥加密数据
	*
	* @param    plain               [in]    待加密数据,1-1900字节
	* @param    publicKeyIndexOrDer [in]    SM2公钥索引或ASN.1格式的DER编码数据
	* @param    cipher              [out]   加密后的密文数据,64字节C1||32字节C3||n字节密文C2
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE3_SM2PublicKeyEncrypt(
		FRM_INT8_PTR plain,
		FRM_INT8_PTR publicKeyIndexOrDer,
		FRM_INT8_PTR* cipher);
	/**
	* @brief    指令E4,使用SM2私钥解密数据
	*
	* @param    cipher                  [in]    待解密的数据,97-1996字节
	* @param    privateKeyIndexOrCipher [in]    SM2私钥索引或LMK加密的私钥密文
	* @param    plain                   [out]   输出加密后的明文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE4_SM2PrivateKeyDecrypt(
		FRM_INT8_PTR cipher,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR* plain);
	/**
	* @brief    指令E5,使用 SM2 私钥计算数据的签名值
	*
	* @param    userId              [in]    用户ID,0-32字节
	* @param    data                [in]    待签名数据,0-1984字节
	* @param    keyIndex            [in]    密钥索引1-64,为NULL时使用私钥密文和公钥DER编码形式
	* @param    publicKeyDer        [in]    公钥DER编码
	* @param    privateKeyCipher    [in]    LMK加密的私钥密文
	* @param    signatureFormat     [in]    签名的数据格式,
	*                                       0-签名值数据串(r/s序列),1-DER 编码格式(r/s序列编码),整数使用2的补码表示法
	* @param    signature           [out]   数据签名，rs 序列
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE5_SM2PrivateKeySign(
		FRM_INT8_PTR userId,
		FRM_INT8_PTR data,
		FRM_INT8_PTR keyIndex,
		FRM_INT8_PTR publicKeyDer,
		FRM_INT8_PTR privateKeyCipher,
		FRM_INT8_PTR signatureFormat,
		FRM_INT8_PTR* signature);
	/**
	* @brief    指令E6,使用SM2公钥验证数据的签名值;用户标识若不存在,则采用国密局发布的默认ID:"1234567812345678"
	*
	* @param    userId              [in]    用户ID,0-32字节
	* @param    signatureFormat     [in]    签名的数据格式
	*                                       0-签名值数据串(r/s序列),1-DER 编码格式(r/s序列编码),整数使用2的补码表示法
	* @param    signature           [in]    签名,64-80字节
	* @param    data                [in]    被签名数据,0-1984字节
	* @param    publicKeyIndexOrDer [in]    公钥索引或DER格式编码
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE6_SM2PublicKeyVerify(
		FRM_INT8_PTR userId,
		FRM_INT8_PTR signatureFormat,
		FRM_INT8_PTR signature,
		FRM_INT8_PTR data,
		FRM_INT8_PTR publicKeyIndexOrDer);
	/**
	* @brief    指令ED,使用SM2私钥计算数据的签名值;仅对数据的摘要值(32字节)进行SM2私钥签名运算,摘要的产生由应用系统自行负责
	*
	* @param    digest                  [in]    32字节摘要
	* @param    privateKeyIndexOrCipher [in]    私钥索引或LMK加密的私钥密文
	* @param    signatureFormat         [in]    签名的数据格式
	*                                           0-签名值数据串(r/s序列),1-DER 编码格式(r/s序列编码),整数使用2的补码表示法
	* @param    signature               [out]   输出数据签名
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverED_SM2PrivateKeySignWithDataDigest(
		FRM_INT8_PTR digest,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR signatureFormat,
		FRM_INT8_PTR* signature);
	/**
	* @brief    指令EF,使用SM2公钥验证签名值;该指令仅对数据的摘要值(32字节)进行SM2公钥验证运算,数据摘要的产生由应用系统自行负责
	*
	* @param    signatureFormat     [in]    签名的数据格式
	*                                        0-签名值数据串(r/s序列),1-DER 编码格式(r/s序列编码),整数使用2的补码表示法
	* @param    signature           [in]    待验证数据签名,64-80字节
	* @param    digest              [in]    32字节摘要
	* @param    publicKeyIndexOrDer [in]    公钥索引或DER编码
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEF_SM2PublicKeyVerifyWithDataDigest(
		FRM_INT8_PTR signatureFormat,
		FRM_INT8_PTR signature,
		FRM_INT8_PTR digest,
		FRM_INT8_PTR publicKeyIndexOrDer);
	/**
	* @brief    指令TT,保护密钥(对称)加密导出一对 SM2 密钥
	*
	* @param    algorithmMode               [in]    加密时的运算模式,限00/01
	* @param    symmKeyType                 [in]    保护密钥类型,限000/109或KEK/MDK
	* @param    symmKeyIndexOrCipher        [in]    保护密钥索引或密文
	* @param    symmKeyDiversifyFactor      [in]    保护密钥分散因子,每级16字节,最多8级
	* @param    sm2KeyIndex                 [in]    导出的SM2密钥索引,1-64有效,
	*                                               为NULL时导出publicKeyDerIn和privateKeyCipherByLmk描述的密钥对
	* @param    publicKeyDerIn              [in]    公钥DER编码,KeyIndex为NULL时有效
	* @param    privateKeyCipherByLmk       [in]    LMK加密的私钥密文,KeyIndex为NULL时有效
	* @param    publicKeyDerOut             [out]   公钥DER编码
	* @param    privateKeyCipherBySymmKey   [out]   对称保护密钥加密的私钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTT_SymmetricProtectKeyExportSM2KeyPair(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmKeyIndexOrCipher,
		FRM_INT8_PTR symmKeyDiversifyFactor,
		FRM_INT8_PTR sm2KeyIndex,
		FRM_INT8_PTR publicKeyDerIn,
		FRM_INT8_PTR privateKeyCipherByLmk,
		FRM_INT8_PTR* publicKeyDerOut,
		FRM_INT8_PTR* privateKeyCipherBySymmKey);
	/**
	* @brief    指令TU,保护密钥(对称)加密导入一对 SM2 密钥
	*
	* @param    algorithmMode               [in]    加密时的运算模式,限00/01
	* @param    symmKeyType                 [in]    保护密钥类型,限000/109或KEK/MDK
	* @param    symmKeyIndexOrCipher        [in]    保护密钥索引或密文
	* @param    symmKeyDiversifyFactor      [in]    保护密钥分散因子,每级16字节,最多8级
	* @param    storeIndex                  [in]    存储到加密机的索引号1-64,为NULL时不存储到加密机
	* @param    storeTag                    [in]    存储到加密机的标签,storeIndex不为NULL时有效
	* @param    publicKeyDer                [in]    公钥DER编码
	* @param    privateKeyCipherBySymmKey   [in]    对称保护密钥加密的私钥密文
	* @param    privateKeyCipherByLmk       [out]   LMK加密的私钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTU_SymmetricProtectKeyImportSM2KeyPair(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmKeyIndexOrCipher,
		FRM_INT8_PTR symmKeyDiversifyFactor,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR publicKeyDer,
		FRM_INT8_PTR privateKeyCipherBySymmKey,
		FRM_INT8_PTR* privateKeyCipherByLmk);
	/**
	* @brief    指令TX,SM2公钥加密导出一条对称密钥
	*
	* @param    symmKeyType             [in]    被导出对称密钥的类型,限000/00A/109或KEK/DEK/MDK
	* @param    symmKeyIndexOrCipher    [in]    被导出对称密钥的索引或密文
	* @param    diversifyFactor         [in]    分散因子数据,每级16字节,最多8级
	* @param    publicKeyIndexOrDer     [in]    SM2公钥索引或ASN.1格式的DER编码数据
	* @param    publicKeyAuthData       [in]    SM2公钥认证数据,0-128字节,当publicKeyIndexOrPlain为外部传入的明文时生效
	* @param    publicKeyMac            [in]    SM2公钥MAC数据,当publicKeyIndexOrPlain为外部传入的明文时生效
	* @param    keyCipherByPublic       [out]   SM2公钥加密的对称密钥(或子密钥)密文数据
	* @param    keyCheckValue           [out]   导出密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTX_SM2PublicKeyExportSymmetricKey(
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmKeyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR publicKeyIndexOrDer,
		FRM_INT8_PTR publicKeyAuthData,
		FRM_INT8_PTR publicKeyMac,
		FRM_INT8_PTR* keyCipherByPublic,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    指令TY,SM2公钥保护导入一条对称密钥
	*
	* @param    symmKeyType             [in]    被导入对称密钥的类型,限000/00A/109或KEK/DEK/MDK
	* @param    symmAlg                 [in]    被导入对称密钥的算法标识,如X/DES2
	* @param    symmKeyCipherByPublic   [in]    被导入对称密钥的公钥加密密文
	* @param    symmKeyCheckValue       [in]    被导入对称密钥的校验值,全0或NULL则不校验
	* @param    storeIndex              [in]    被导入对称密钥的存储标识,范围为1-2048,为0不存储
	* @param    storeTag                [in]    被导入对称密钥的在密码机内的存储标签,storeIndex不为0时有效
	* @param    privateKeyIndexOrCipher [in]    保护公钥对应的私钥索引或在LMK下加密的私钥密文
	* @param    keyCipherByLmk          [out]   LMK加密的对称密钥(或子密钥)密文数据
	* @param    keyCheckValue           [out]   导入密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTY_SM2PublicKeyImportSymmetricKey(
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR symmKeyCipherByPublic,
		FRM_INT8_PTR symmKeyCheckValue,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    指令TQ, 对外部送入的SM2公钥计算认证MAC
	*
	* @param    publicKeyDerIn      [in]    SM2公钥ASN.1格式的DER编码数据
	* @param    authenticateData    [in]    认证数据,0-128字节,计算MAC的附加认证数据,";"之外任意可见字符
	* @param    mac                 [out]   输出公钥的认证MAC数据
	* @param    publicKeyDerOut     [out]   SM2公钥ASN.1格式的DER编码数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTQ_GenerateSM2PublicKeyMAC(
		FRM_INT8_PTR publicKeyDerIn,
		FRM_INT8_PTR authenticateData,
		FRM_INT8_PTR* mac,
		FRM_INT8_PTR* publicKeyDerOut);
	/**
	* @brief    指令FS,使用 ECC 私钥计算数据的签名值
	*
	* @param    hashAlg					[in]    HASH算法
	*											05 - SHA-224
	*											06 - SHA-256
	*											07 - SHA-384
	*											08 - SHA-512
	* @param    curveId					[in]    曲线标识
	*											20 - NID_NISTP192v1
	*											21 - NID_NISTP192v2
	*											22 - NID_NISTP192v3
	*											23 - NID_SECP192K1,
	*											30 - NID_NISTP256,
	*											31 - NID_BRAINPOOLP256R1,
	*											32 - NID_FRP256V1
	*											33 - NID_SECP256K1
	*											44 - NID_X25519
	* @param    data					[in]    待签名数据,0-1984字节
	* @param    privateKeyIndexOrCipher	[in]    私钥索引或LMK加密的私钥密文
	* @param    signatureFormat			[in]    签名的数据格式,
	*											0-签名值数据串(r/s序列),1-DER 编码格式(r/s序列编码),整数使用2的补码表示法
	* @param    signature				[out]   数据签名
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverFS_ECCPrivateKeySign(
		FRM_INT8_PTR hashAlg,
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR data,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR signatureFormat,
		FRM_INT8_PTR* signature);
	/**
	* @brief    指令FV,使用 ECC 公钥验证数据的签名值
	*
	* @param    hashAlg					[in]    HASH算法
	*											05 - SHA-224
	*											06 - SHA-256
	*											07 - SHA-384
	*											08 - SHA-512
	* @param    curveId					[in]    曲线标识
	*											20 - NID_NISTP192v1
	*											21 - NID_NISTP192v2
	*											22 - NID_NISTP192v3
	*											23 - NID_SECP192K1,
	*											30 - NID_NISTP256,
	*											31 - NID_BRAINPOOLP256R1,
	*											32 - NID_FRP256V1
	*											33 - NID_SECP256K1
	*											44 - NID_X25519
	* @param    signature				[in]    签名,64-80字节
	* @param    data					[in]    被签名数据,0-1984字节
	* @param    publicKeyIndexOrDer		[in]    公钥索引或DER格式编码
	* @param    signatureFormat			[in]    签名的数据格式
	*											0-签名值数据串(r/s序列),1-DER 编码格式(r/s序列编码),整数使用2的补码表示法
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverFV_ECCPublicKeyVerify(
		FRM_INT8_PTR hashAlg,
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR signatureFormat,
		FRM_INT8_PTR signature,
		FRM_INT8_PTR data,
		FRM_INT8_PTR publicKeyIndexOrDer);
	/**
	* @brief    指令EL,使用 ECC 加密数据
	*
	* @param    curveId					[in]    曲线标识
	*											20 - NID_NISTP192v1
	*											21 - NID_NISTP192v2
	*											22 - NID_NISTP192v3
	*											23 - NID_SECP192K1,
	*											30 - NID_NISTP256,
	*											31 - NID_BRAINPOOLP256R1,
	*											32 - NID_FRP256V1
	*											33 - NID_SECP256K1
	*											44 - NID_X25519
	* @param    publicKeyIndexOrDer		[in]    公钥索引或DER格式编码
	* @param    Ephemeral				[in]    Ephemeral私钥使用标识，0-使用随机密钥
	* @param    hashAlg					[in]    HASH算法
	*											05 - SHA-224
	*											06 - SHA-256
	*											07 - SHA-384
	*											08 - SHA-512
	* @param    algorithmMode			[in]    对称密钥加密算法模式
	01 – AES-128-ECB
	02 – AES-128-CBC
	03 – AES-256-ECB
	04 – AES-256-CBC
	05 – AES-128-GCM
	06 – AES-256-GCM
	07 – 3DES-128-ECB
	08 – 3DES-128-CBC
	09 – 3DES-196-ECB
	10 – 3DES-196-CBC
	* @param    Adata					[in]	Adata数据，当为GCM算法时存在该域
	* @param    ivlen					[in]    当为AES-GCM算法时存在该域
	* @param    iv						[in]    初始向量
	当对称算法CBC与GCM模式时为存在
	且当算法为AES-ECB/AES-CBC算法时为32H,
	且当算法为3DES-ECB/3DES-CBC算法时为16H
	且当算法为AES-GCM时长度由IV长度域决定
	* @param    SharedinfoS1			[in]    (共享加密信息）S1,用于KDF分散密钥k
	* @param    HMACmode				[in]    0 - 不计算HMAC
												1 - 计算 HMAC
	* @param    HMACalg             	[in]    HMAC算法标识,当HMACmode标识为1时存在
												06 : SHA-256
												08 : SHA-512
	* @param    SharedinfoS2			[in]    (共享加密信息）S2,当HMACmode标识为1时存在
	* @param    padMode					[in]    填充模式,如00,取值范围：00–05或10 - 11,当算法不为GCM时生效
	* @param    data					[in]    待加密数据
	* @param    Ephemeralr				[out]   内部随机产生的公钥，用于KDF产生密钥
	* @param    cipher					[out]   密文数据
	* @param    HMAC					[out]   所有密文的HMAC，当HMAC标识为1时存在
	* @param    TAG						[out]   当为GCM算法时存在该域
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEL_ECCDataEncrypt(
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR publicKeyIndexOrDer,
		FRM_INT8_PTR Ephemeral,
		FRM_INT8_PTR hashAlg,
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR Adata,
		FRM_INT8_PTR ivlen,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR SharedinfoS1,
		FRM_INT8_PTR HMACmode,
		FRM_INT8_PTR HMACalg,
		FRM_INT8_PTR SharedinfoS2,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* Ephemeralr,
		FRM_INT8_PTR* cipher,
		FRM_INT8_PTR* HMAC,
		FRM_INT8_PTR* TAG);
	/**F
	* @brief    指令EM,使用 ECC 解密 数据
	*
	* @param    curveId					[in]    曲线标识
	*											20 - NID_NISTP192v1
	*											21 - NID_NISTP192v2
	*											22 - NID_NISTP192v3
	*											23 - NID_SECP192K1,
	*											30 - NID_NISTP256,
	*											31 - NID_BRAINPOOLP256R1,
	*											32 - NID_FRP256V1
	*											33 - NID_SECP256K1
	*											44 - NID_X25519
	* @param    publicKeyIndexOrDer		[in]    公钥索引或DER格式编码
	* @param    privateKeyIndexOrCipher	[in]    私钥索引或LMK加密的私钥密文
	* @param    hashAlg					[in]    HASH算法
	*											05 - SHA-224
	*											06 - SHA-256
	*											07 - SHA-384
	*											08 - SHA-512
	* @param    algorithmMode			[in]    对称密钥加密算法模式
												01 – AES-128-ECB
												02 – AES-128-CBC
												03 – AES-256-ECB
												04 – AES-256-CBC
												05 – AES-128-GCM
												06 – AES-256-GCM
												07 – 3DES-128-ECB
												08 – 3DES-128-CBC
												09 – 3DES-196-ECB
												10 – 3DES-196-CBC
	* @param    Adata					[in]	Adata数据，当为GCM算法时存在该域
	* @param    ivlen					[in]    当为AES-GCM算法时存在该域
	* @param    iv						[in]    初始向量
												当对称算法CBC与GCM模式时为存在
												且当算法为AES-ECB/AES-CBC算法时为32H,
												且当算法为3DES-ECB/3DES-CBC算法时为16H
												且当算法为AES-GCM时长度由IV长度域决定
	* @param    TAG						[in]    当为GCM算法时存在该域
	* @param    SharedinfoS1			[in]    (共享加密信息）S1,用于KDF分散密钥k
	* @param    HMACmode				[in]    0 - 不计算HMAC
												1 - 计算 HMAC
	* @param    HMACalg             	[in]    HMAC算法标识,当HMACmode标识为1时存在
												06 : SHA-256
												08 : SHA-512
	* @param    SharedinfoS2			[in]    (共享加密信息）S2,当HMACmode标识为1时存在
	* @param    HMAC					[in]    所有密文的HMAC，当HMAC标识为1时存在
	* @param    padMode					[in]    填充模式,如00,取值范围：00–05或10 - 11,当算法不为GCM时生效
	* @param    data					[in]    待解密数据
	* @param    plain					[out]   输出明文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverEM_ECCDataDecrypt(
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR publicKeyIndexOrDer,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR hashAlg,
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR Adata,
		FRM_INT8_PTR ivlen,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR TAG,
		FRM_INT8_PTR SharedinfoS1,
		FRM_INT8_PTR HMACmode,
		FRM_INT8_PTR HMACalg,
		FRM_INT8_PTR SharedinfoS2,
		FRM_INT8_PTR HMAC,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* plain);
	/**
	* @brief    指令T4,密钥协商
	*
	* @param    curveId					[in]    曲线标识
	*											23 - NID_SECP192K1,
	*											30 - NID_NISTP256,
	*											33 - NID_SECP256K1
	*											44 - NID_X25519
	* @param    hashAlg					[in]    HASH算法
	*											00 - NONE
	*											02 : SHA-224
	*											03 : SHA-256
	*											04 : SHA-384
	*											05 : SHA-512
	* @param    privateKeyIndexOrCipher	[in]    私钥索引或LMK加密的私钥密文
	* @param    publicKeyDer		    [in]    公钥DER格式编码
	* @param    symmKeyType             [in]    密钥类型,00A –DEK
	* @param    symmAlg                 [in]    算法标识
	* @param    keyCipher               [out]   密钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverT4_KeyAgreement(
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR hashAlg,
		FRM_INT8_PTR privateKeyIndexOrCipher,
		FRM_INT8_PTR publicKeyDer,
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR* keyCipher);
	//-以上非对称应用主机命令
	//区块链
	/**
	* @brief    生成根密钥
	*
	* @param    keyComp          [in]    密钥分量
	* @param    seed             [in]    种子
	* @param    privateKey       [out]   私钥（Base58编码）
	* @param    publicKey        [out]   公钥（Base58编码）
	* @param    address          [out]   地址（Base58编码）
	* @param    chainCode        [out]   地址（Base58编码）
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverB1_BlockChainGenerateRootKey(
		FRM_INT8_PTR  keyComp,
		FRM_INT8_PTR  seed,
		FRM_INT8_PTR* privateKeyBase,
		FRM_INT8_PTR* publicKeyBase,
		FRM_INT8_PTR* addressBase,
		FRM_INT8_PTR* chainCode);
	/**
	* @brief    派生子密钥
	*
	* @param    rootKeyType          [in]    父密钥类型
	* @param    rootKey              [in]    父密钥
	* @param    path                 [in]    路径
	* @param    privateKeyBase       [out]   私钥（Base58编码）
	* @param    publicKeyBase        [out]   公钥（Base58编码）
	* @param    addressBase          [out]   地址（Base58编码）
	* @param    chainCode            [out]   地址（Base58编码）
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverB2_BlockChainDerivedkey(
		FRM_INT8_PTR  rootKeyType,
		FRM_INT8_PTR  rootKey,
		FRM_INT8_PTR  path,
		FRM_INT8_PTR* privateKeyBase,
		FRM_INT8_PTR* publicKeyBase,
		FRM_INT8_PTR* addressBase,
		FRM_INT8_PTR* chainCode);
	/**
	* @brief    签名B3
	*
	* @param    privateKeyCipher       [in]    私钥
	* @param    data                   [in]    数据
	* @param    codFormat              [in]    编码格式
	* @param    signature              [out]   地址（Base58编码）
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverB3_BlockChainSign(
		FRM_INT8_PTR  privateKeyCipher,
		FRM_INT8_PTR  data,
		FRM_INT8_PTR  codFormat,
		FRM_INT8_PTR* signature);
	/**
	* @brief    验签B4
	*
	* @param    publicKeyBase    [in]    公钥（Base58）
	* @param    data             [in]    原始数据
	* @param    codFormat        [in]    编码格式
	* @param    signVerif        [in]   待验证签名
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverB4_BlockChainVerify(
		FRM_INT8_PTR  publicKeyBase,
		FRM_INT8_PTR  data,
		FRM_INT8_PTR  codFormat,
		FRM_INT8_PTR  signVerif);
	/**
	* @brief    签名RFC6979规范之外数参数(B5)
	*
	* @param    privateKeyCipher       [in]    私钥（Base58）
	* @param    dataH                  [in]    数据H
	* @param    dataR                  [in]    数据R
	* @param    dataK                  [in]    数据K
	* @param    dataQ                  [in]    数据Q
	* @param    signVerif              [in]    签名数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverB5_BlockChainSignRFC(
		FRM_INT8_PTR  privateKeyCipher,
		FRM_INT8_PTR  dataH,
		FRM_INT8_PTR  dataR,
		FRM_INT8_PTR  dataK,
		FRM_INT8_PTR  dataQ,
		FRM_INT8_PTR* signature);
	/**
	* @brief    派生子密钥输出非压缩公钥Base58编码（B6）
	*
	* @param    rootKeyType         [in]    父密钥类型
	* @param    rootKey             [in]    父密钥
	* @param    path                [in]    路径,0-4096字节
	* @param    privateKeyCipher    [in]    私钥
	* @param    publicKeyDer        [in]    公钥DER
	* @param    publicKey           [in]    公钥
	* @param    address             [in]    地址
	* @param    chainCode           [in]    chainCode
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverB6_BlockChainDerivedKeyOut(
		FRM_INT8_PTR  rootKeyType,
		FRM_INT8_PTR  rootKey,
		FRM_INT8_PTR  path,
		FRM_INT8_PTR* privateKeyCipher,
		FRM_INT8_PTR* publicKeyDer,
		FRM_INT8_PTR* publicKey,
		FRM_INT8_PTR* address,
		FRM_INT8_PTR* chainCode);
	/**
	* @brief    签名(B7) 外置k-RFC6979(B7)
	*
	* @param    curveId          [in]    曲线标识
	* @param    hashFlag         [in]    HASH算法标识
	* @param    keyIndex         [in]    密钥索引标识（取值为K）
	* @param    privateKeyCipher [in]    私钥密文
	* @param    randomNum        [in]    随机数
	* @param    dataAlg          [in]    数据格式
	* @param    data             [in]    数据，0-984字节
	* @param    signatureFormat  [in]    签名编码格式
	* @param    signature        [out]   签名
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverB7_BlockChainGenerateSign(
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR hashFlag,
		FRM_INT8_PTR keyIndex,
		FRM_INT8_PTR privateKeyCipher,
		FRM_INT8_PTR randomNum,
		FRM_INT8_PTR dataAlg,
		FRM_INT8_PTR data,
		FRM_INT8_PTR signatureFormat,
		FRM_INT8_PTR* signature);
	/**
	* @brief    密钥派生之输出LMK密文(B8)
	*
	* @param    rootKey              [in]    父密钥类型
	* @param    curveId              [in]    曲线标识
	* @param    keyIndex             [in]    密钥索引标识（取值为K）
	* @param    publicKeyDer         [in]    公钥DER
	* @param    privateKeyCipher     [in]    私钥密文
	* @param    chainCode            [in]    链码
	* @param    path                 [in]    路径长度
	* @param    privateKeyCipherOut  [in]    私钥
	* @param    publicKeyDerOut      [in]    公钥
	* @param    chainCodeOut         [out]   链码
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverB8_BlockChainKeyDerived(
		FRM_INT8_PTR rootKey,
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR keyIndex,
		FRM_INT8_PTR publicKeyDer,
		FRM_INT8_PTR privateKeyCipher,
		FRM_INT8_PTR chainCode,
		FRM_INT8_PTR path,
		FRM_INT8_PTR* privateKeyCipherOut,
		FRM_INT8_PTR* publicKeyDerOut,
		FRM_INT8_PTR* chainCodeOut);
	//-以下新增指令
	/**
	* @brief    AM指令,明文成分合成密钥
	*
	* @param    keyType         [in]    生成密钥的类型标识
	* @param    symmAlg         [in]    生成密钥的算法标识
	* @param    comp[in]    成分串联,每个成分长度等于密钥长度
	* @param    storeIndex                  [in]    生成密钥的存储索引,0-2048(为0时表示不存储到加密机内部)
	* @param    storeTag        [in]    密钥存储到加密机时的标签,0到16位字符(storeIndex为0时无效)
	* @param    keyCipherByLmk  [out]   输出生成的密钥在LMK下加密的密文
	* @param    keyCheckValue   [out]   输出生成的密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverAM_PlainCompositionCompoundKey(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR comp,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    AN指令,密钥类型转换
	*
	* @param    srcKeyType          [in]    源密钥类型,如109/MDK
	* @param    srcKeyIndexOrCipher [in]    源密钥索引或LMK加密的密文
	* @param    dstKeyType          [in]    目标密钥类型,如109/MDK
	* @param    symmAlg             [in]    密钥算法,如X/DES2
	* @param    dstKeyCipherByLmk   [out]   密钥在LMK下加密的密文
	* @param    keyCheckValue       [out]   密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverAN_SymmetricKeyTypeConvert(
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR dstKeyType,
		FRM_INT8_PTR symmAlg,
		FRM_INT8_PTR* dstKeyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    指令CM, 计算密文PINBLOCK的MD5校验值(不建议使用)
	*
	* @param    zpkInputWay         [in]    ZPK密钥的输入方式,
	*                                       1:输入ZMK保护的ZPK密钥或索引,2:输入LMK保护的ZPK密钥或索引
	* @param    zmkIndexOrCipher    [in]    ZMK密钥索引或密文,zpkInputWay为1时有效
	* @param    zpkCipherByZmk      [in]    ZPK被ZMK加密(ECB模式)的密钥密文,zpkInputWay为1时有效
	* @param    zpkIndexOrCipher    [in]    ZPK密钥索引或LMK加密的密文,zpkInputWay为2时有效
	* @param    pinBlockCipher      [in]    PINBLOCK密文,8/16字节
	* @param    pinBlockFormat      [in]    PINBLOCK格式代码,参见PINBLOCK(数字)格式
	* @param    accountNum          [in]    ZPK下加密PIN块时使用的用户主账号,
	*                                       当pinBlockFormat=4时为18位,不足18位左补F,其余情况12位数字
	* @param    md5                 [out]   PIN的MD5
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverCM_CalculatePINCipherMD5(
		FRM_INT8_PTR zpkInputWay,
		FRM_INT8_PTR zmkIndexOrCipher,
		FRM_INT8_PTR zpkCipherByZmk,
		FRM_INT8_PTR zpkIndexOrCipher,
		FRM_INT8_PTR pinBlockCipher,
		FRM_INT8_PTR pinBlockFormat,
		FRM_INT8_PTR accountNum,
		FRM_INT8_PTR* md5);
	/**
	* @brief    HX指令,采用密文密钥对输入数据计算 HMAC 值
	*
	* @param    hashFlag            [in]    HASH算法模式标识:
	*                                       06:SHA-256,
	*                                       08:SHA-512, 20:SM3-256
	* @param    keyType             [in]    密钥类型,003/008或TAK/ZAK
	* @param    keyIndexOrCipher    [in]    源密钥索引或LMK加密的密文
	* @param    data                [in]    输入数据,1-1984字节
	* @param    hmac                [out]   HMAC
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverHX_CalculateDataHMAC_CipherKey(
		FRM_INT8_PTR hashFlag,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* hmac);
	/**
	* @brief    指令HT,导出对称密钥(不建议使用)
	*
	* @param    kdfHash                 [in]    KDF_HASH算法,01(SHA1)
	* @param    tmpKeyEncryptSchem      [in]    临时密钥加密方案,L(AES-WRAP)
	* @param    kekLen                  [in]    kekLen必须为16
	* @param    aesWrapIV               [in]    AES-WRAP-IV
	* @param    symmKeyType             [in]    密钥类型,如109/MDK
	* @param    symmKeyIndexOrCipher    [in]    被导出对称密钥索引或密文
	* @param    publicKeyDer            [in]    公钥DER
	* @param    c1                      [out]   C1
	* @param    c2                      [out]   C2
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverHT_PublicKeyExportSymmetricKey(
		FRM_INT8_PTR kdfHash,
		FRM_INT8_PTR tmpKeyEncryptScheme,
		FRM_INT8_PTR kekLen,
		FRM_INT8_PTR aesWrapIV,
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmKeyIndexOrCipher,
		FRM_INT8_PTR publicKeyDer,
		FRM_INT8_PTR* c1,
		FRM_INT8_PTR* c2);
	/**
	* @brief    KS指令,欧贝特定制指令
	*
	* @param    srcKeyType          [in]    源密钥类型,如109/MDK
	* @param    srcKeyIndexOrCipher [in]    源密钥索引或LMK加密的密文
	* @param    childKeyType        [in]    子密钥类型,如109/MDK
	* @param    childSymmAlg        [in]    子密钥算法,如X/DES2
	* @param    diversifyMode       [in]    分散模式,6-8：CMAC KDF(AES CMAC)/ECB/CBC
	* @param    diversifyTime       [in]    分散次数
	* @param    diversifyFactor     [in]    分散因子(串联)
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式
	* @param    sessionKeyDivTime   [in]    会话密钥迭代次数，sessionKeyGenMode = 07是有效
	* @param    sessionKeyFactor    [in]    会话密钥因子
	* @param    keyCheckValueAlg    [in]    校验值算法
	* @param    expandFactor        [in]    扩展因子，为NULL时无效
	* @param    storeIndex          [in]    生成密钥的存储索引,1-2048时有效,为NULL时不存储
	* @param    storeTag            [in]    密钥存储到加密机时的标签,0到16位字符,storeIndex有效时启用
	* @param    keyCipherByLmk      [out]   生成密钥在LMK下加密的密文
	* @param    keyCheckValue       [out]   生成密钥的校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKS_DiversifyKey(
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR childKeyType,
		FRM_INT8_PTR childSymmAlg,
		FRM_INT8_PTR diversifyMode,
		FRM_INT8_PTR diversifyTime,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyDivTime,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR keyCheckValueAlg,
		FRM_INT8_PTR expandFactor,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    T2指令,AES-GCM模式加密
	*
	* @param    algorithmMode       [in]    加密时的运算模式,如00/ECB
	* @param    keyType             [in]    密钥类型,KEK/DEK(000/00A)
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子,每级16字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor    [in]    会话密钥因子,16字节,当sessionKeyGenMode值为02/05时有效
	* @param    data                [in]    待加密数据,0-1968字节
	* @param    iv                  [in]    初始向量,1-128字节
	* @param    aad                 [in]    AAD,0-256字节
	* @param    tagOutLength        [in]    TAG输出长度
	* @param    cipher              [out]   输出密文数据
	* @param    tag                 [out]   标签
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverT2_AES_GCM_DataEncrypt(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR aad,
		FRM_INT8_PTR tagOutLength,
		FRM_INT8_PTR* cipher,
		FRM_INT8_PTR* tag);
	/**
	* @brief    T3指令,AES-GCM模式解密
	*
	* @param    algorithmMode       [in]    加密时的运算模式,如00/ECB
	* @param    keyType             [in]    密钥类型,KEK/DEK(000/00A)
	* @param    keyIndexOrCipher    [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor     [in]    分散因子,每级16字节,最多8级
	* @param    sessionKeyGenMode   [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor    [in]    会话密钥因子,16字节,当sessionKeyGenMode值为02/05时有效
	* @param    data                [in]    待加密数据,0-1968字节
	* @param    iv                  [in]    初始向量,1-128字节
	* @param    aad                 [in]    AAD,0-256字节
	* @param    tag                 [in]    TAG
	* @param    plain               [out]   输出明文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverT3_AES_GCM_DataDecrypt(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR data,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR aad,
		FRM_INT8_PTR tag,
		FRM_INT8_PTR* plain);
	/**
	* @brief    KL指令,数据转加密,AES算法转加密，将源密钥A加密的数据密文转换到目标密钥B下加密
	*
	* @param    srcAlgorithmMode        [in]    源密钥加密时的运算模式,00/01/02:ECB/CBC/AES-GCM
	* @param    srcKeyType              [in]    源密钥类型,如109/MDK
	* @param    srcKeyIndexOrCipher     [in]    源密钥索引或LMK加密的密文
	* @param    srcDiversifyFactor      [in]    源密钥分散因子,每级16字节,最多8级
	* @param    srcSessionKeyGenMode    [in]    源密钥会话密钥产生模式,00/02/05
	* @param    srcSessionKeyFactor     [in]    源密钥会话密钥因子,16字节,当srcSessionKeyGenMode值为02/05时有效
	* @param    srcPadMode              [in]    源密钥加密时数据的填充模式,如00
	* @param    srcIv                   [in]    源初始向量,srcAlgorithmMode为01/02时有效
	* @param    srcAad                  [in]    源AAD,srcAlgorithmMode为02时有效
	* @param    srcTag                  [in]    源TAG,srcAlgorithmMode为02时有效
	* @param    dstAlgorithmMode        [in]    目标密钥加密时的运算模式,00/01/02:ECB/CBC/AES-GCM
	* @param    dstKeyType              [in]    目标密钥类型,如109/MDK
	* @param    dstKeyIndexOrCipher     [in]    目标密钥索引或LMK加密的密文
	* @param    dstDiversifyFactor      [in]    目标密钥分散因子,每级16字节,最多8级
	* @param    dstSessionKeyGenMode    [in]    目标密钥会话密钥产生模式,00/02/05
	* @param    dstSessionKeyFactor     [in]    目标密钥会话密钥因子,16字节,当dstSessionKeyGenMode值为02/05时有效
	* @param    dstPadMode              [in]    目标密钥加密时数据的填充模式,如00
	* @param    dstIv                   [in]    目标初始向量,dstAlgorithmMode为01/02时有效
	* @param    dstAad                  [in]    目标AAD,dstAlgorithmMode为02时有效
	* @param    dstTagOutLength         [in]    目标TAG长度,dstAlgorithmMode为02时有效
	* @param    cipherBySrcKey          [in]    源密钥加密数据
	* @param    cipherByDstKey          [out]   目标密钥加密数据
	* @param    dstTag                  [out]   目标标签
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverKL_AES_GCM_DataTranscrypt(
		FRM_INT8_PTR srcAlgorithmMode,
		FRM_INT8_PTR srcKeyType,
		FRM_INT8_PTR srcKeyIndexOrCipher,
		FRM_INT8_PTR srcDiversifyFactor,
		FRM_INT8_PTR srcSessionKeyGenMode,
		FRM_INT8_PTR srcSessionKeyFactor,
		FRM_INT8_PTR srcPadMode,
		FRM_INT8_PTR srcIv,
		FRM_INT8_PTR srcAad,
		FRM_INT8_PTR srcTag,
		FRM_INT8_PTR dstAlgorithmMode,
		FRM_INT8_PTR dstKeyType,
		FRM_INT8_PTR dstKeyIndexOrCipher,
		FRM_INT8_PTR dstDiversifyFactor,
		FRM_INT8_PTR dstSessionKeyGenMode,
		FRM_INT8_PTR dstSessionKeyFactor,
		FRM_INT8_PTR dstPadMode,
		FRM_INT8_PTR dstIv,
		FRM_INT8_PTR dstAad,
		FRM_INT8_PTR dstTagOutLength,
		FRM_INT8_PTR cipherBySrcKey,
		FRM_INT8_PTR* cipherByDstKey,
		FRM_INT8_PTR* dstTag);

	/**
	* @brief    SW指令,多条数据加解密
	*
	* @param    encryptOrDecryptFlag    [in]    加/解密标识
	*                                           0：加密
	*                                           1：解密
	* @param    algorithmMode           [in]    加密或解密运算模式,00/01/02/03:ECB/CBC/CFB/OFB
	* @param    keyType                 [in]    密钥类型,如109/MDK
	* @param    keyIndexOrCipher        [in]    密钥索引或LMK加密的密文
	* @param    diversifyFactor         [in]    密钥分散因子,每级16字节,最多8级
	* @param    sessionKeyGenMode       [in]    密钥会话密钥产生模式,01-05
	* @param    sessionKeyFactor        [in]    密钥会话密钥因子,16字节,当sessionKeyGenMode值为01/02/05时有效
	* @param    padMode                 [in]    密钥加/解密时数据的填充模式,如00
	* @param    dataInRecordCnt         [in]    加/解密数据的条数
	* @param    dataIn                  [in]    加/解密数据
	* @param    iv                      [in]    初始向量,algorithmMode为01/02/03时有效
	* @param    dataOut                 [out]   解/加密数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverSW_MultipleDataRecordEncryptDecrypt(
		FRM_INT8_PTR encryptOrDecryptFlag,
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR keyIndexOrCipher,
		FRM_INT8_PTR diversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR padMode,
		FRM_INT8_PTR dataInRecordCnt,
		FRM_INT8_PTR dataIn[],
		FRM_INT8_PTR iv,
		FRM_INT8_PTR* dataOut[]);

	//新增三条指令
	/**
	* @brief    E7指令,产生指定曲线的SM2/ECC密钥对,可选的存储到密码机内某索引中
	*
	* @param    curveId             [in]    曲线标识
	*										07 - sm2
	*										20 - NID_NISTP192v1
	*										21 - NID_NISTP192v2
	*										22 - NID_NISTP192v3
	*										23 - NID_SECP192K1,
	*										30 - NID_NISTP256,
	*										31 - NID_BRAINPOOLP256R1,
	*										32 - NID_FRP256V1
	*										33 - NID_SECP256K1
	*										44 - NID_X25519
	* @param    storeIndex              [in]    被导入密钥存储索引,1-64,为NULL时不存储到加密机
	* @param    storeTag                [in]    被导入密钥存储标签,0-16个字符,storeIndex有效时启用
	* @param    publicKeyDer            [out]   公钥,ASN.1 格式 DER 编码(模,指数序列)
	* @param    privateKeyCipherByLmk   [out]   LMK加密的私钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverE7_GenerateSM2_ECCKeyPair(
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* publicKeyDer,
		FRM_INT8_PTR* privateKeyCipherByLmk);
	/**
	* @brief    指令TT,保护密钥(对称)加密导出一对 SM2 密钥
	*
	* @param    algorithmMode               [in]    加密时的运算模式,限00/01
	* @param    symmKeyType                 [in]    保护密钥类型,限000/109或KEK/MDK
	* @param    symmKeyIndexOrCipher        [in]    保护密钥索引或密文
	* @param    symmKeyDiversifyFactor      [in]    保护密钥分散因子,每级16字节,最多8级
	* @param    curveId						[in]    曲线标识
	*												07 - sm2
	*												20 - NID_NISTP192v1
	*												21 - NID_NISTP192v2
	*												22 - NID_NISTP192v3
	*												23 - NID_SECP192K1,
	*												30 - NID_NISTP256,
	*												31 - NID_BRAINPOOLP256R1,
	*												32 - NID_FRP256V1
	*												33 - NID_SECP256K1
	*												44 - NID_X25519
	* @param    sm2KeyIndex                 [in]    导出的SM2密钥索引,1-64有效,
	*                                               为NULL时导出publicKeyDerIn和privateKeyCipherByLmk描述的密钥对
	* @param    publicKeyDerIn              [in]    公钥DER编码,KeyIndex为NULL时有效
	* @param    privateKeyCipherByLmk       [in]    LMK加密的私钥密文,KeyIndex为NULL时有效
	* @param    publicKeyDerOut             [out]   公钥DER编码
	* @param    privateKeyCipherBySymmKey   [out]   对称保护密钥加密的私钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTT_SymmetricProtectKeyExportSM2_ECCKeyPair(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmKeyIndexOrCipher,
		FRM_INT8_PTR symmKeyDiversifyFactor,
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR sm2KeyIndex,
		FRM_INT8_PTR publicKeyDerIn,
		FRM_INT8_PTR privateKeyCipherByLmk,
		FRM_INT8_PTR* publicKeyDerOut,
		FRM_INT8_PTR* privateKeyCipherBySymmKey
	);
	/**
	* @brief    指令TU,保护密钥(对称)加密导入一对 SM2 密钥
	*
	* @param    algorithmMode               [in]    加密时的运算模式,限00/01
	* @param    symmKeyType                 [in]    保护密钥类型,限000/109或KEK/MDK
	* @param    symmKeyIndexOrCipher        [in]    保护密钥索引或密文
	* @param    symmKeyDiversifyFactor      [in]    保护密钥分散因子,每级16字节,最多8级
	* @param    curveId						[in]    曲线标识
	*												07 - sm2
	*												20 - NID_NISTP192v1
	*												21 - NID_NISTP192v2
	*												22 - NID_NISTP192v3
	*												23 - NID_SECP192K1,
	*												30 - NID_NISTP256,
	*												31 - NID_BRAINPOOLP256R1,
	*												32 - NID_FRP256V1
	*												33 - NID_SECP256K1
	*												44 - NID_X25519
	* @param    storeIndex                  [in]    存储到加密机的索引号1-64,为NULL时不存储到加密机
	* @param    storeTag                    [in]    存储到加密机的标签,storeIndex不为NULL时有效
	* @param    publicKeyDer                [in]    公钥DER编码
	* @param    privateKeyCipherBySymmKey   [in]    对称保护密钥加密的私钥密文
	* @param    privateKeyCipherByLmk       [out]   LMK加密的私钥密文
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverTU_SymmetricProtectKeyImportSM2_ECCKeyPair(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR symmKeyType,
		FRM_INT8_PTR symmKeyIndexOrCipher,
		FRM_INT8_PTR symmKeyDiversifyFactor,
		FRM_INT8_PTR curveId,
		FRM_INT8_PTR storeIndex,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR publicKeyDer,
		FRM_INT8_PTR privateKeyCipherBySymmKey,
		FRM_INT8_PTR* privateKeyCipherByLmk);

	//SM9算法（15条指令）
	/**
	* @brief    指令M0,产生/装载 系统签名/加密主密钥
	*
	* @param    KeyIndex				[in]    密钥索引
	* @param    keyType		            [in]    密钥类型：1-签名主密钥 2-加密主密钥 3-签名主密钥和加密主密钥 固定为3
	* @param    KeyLength           	[in]    模长，固定为256bit
	* @param    storeTag				[in]    密钥标签 0-16个ASCLL字符
	* @param    signPublicKeyLen		[out]   签名公钥长度
	* @param    signPublicKey 		    [out]   签名公钥
	* @param    EncryptPublicKeyLen		[out]   加密公钥长度
	* @param    EncryptPublicKey 		[out]   加密公钥
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverM0_GenerateMasterKey(
		FRM_INT8_PTR KeyIndex,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR KeyLength,
		FRM_INT8_PTR storeTag,
		FRM_INT8_PTR* signPublicKey,
		FRM_INT8_PTR* EncryptPublicKey);
	/**
	* @brief    指令M1,产生用户私钥
	*
	* @param    keyType				    [in]    密钥类型 1-3
	* @param    UserKeyIndex	        [in]    主公钥索引9999
	* @param    signPublicKey			[in]    签名主公钥，KeyIndexLength为0000时不输入
	* @param    EncryptPublicKey		[in]    KGC加密公钥，长度为模长*2
	* @param    EncryptMode				[in]    加密模式 1-3
	* @param    KeyIndex				[in]    系统主密钥索引
	* @param    userIdLength            [in]    用户ID长度
	* @param    userId                  [in]    用户ID
	* @param    userKeyIndex	    	[in]    用户私钥存储索引，0001-0256
	* @param    pristoreTag      		[in]    标签,当索引不为9999 时存在
	* @param    signPriKey   		    [out]   签名私钥，类型为1/3 时候存在
	* @param    EncryptPriKey    		[out]   加密私钥，类型为2/3 时候存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverM1_GenerateUserPriKey(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR UserKeyIndex,
		FRM_INT8_PTR KeyIndexLength,
		FRM_INT8_PTR signPublicKey,
		FRM_INT8_PTR EncryptPublicKey,
		FRM_INT8_PTR EncryptMode,
		FRM_INT8_PTR KeyIndex,
		FRM_INT8_PTR userId,
		FRM_INT8_PTR userKeyIndex,
		FRM_INT8_PTR pristoreTag,
		FRM_INT8_PTR* signPriKey,
		FRM_INT8_PTR* EncryptPriKey);
	/**
	* @brief    指令M2,导入用户私钥
	*
	* @param    keyType				    [in]    密钥类型 1-3
	* @param    priKeyIndex				[in]    用户加密主私钥索引，0001-0064
	* @param    signPriKey   		    [in]    签名私钥，类型为1/3 时候存在
	* @param    EncryptPriKey    		[in]    加密私钥，类型为2/3 时候存在
	* @param    priKeyStoreIndex		[in]    用户私钥存储索引，0001-0256
	* @param    pristoreTag      		[in]    标签,当索引不为9999 时存在
	* @param    KGCKeyIndex	            [in]    KGC主公钥索引 0001-0064/9999
	* @param    KGCstoreTag      		[in]    标签,当索引不为9999 时存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverM2_ImportUserPriKey(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR priKeyIndex,
		FRM_INT8_PTR signPriKey,
		FRM_INT8_PTR EncryptPriKey,
		FRM_INT8_PTR priKeyStoreIndex,
		FRM_INT8_PTR pristoreTag,
		FRM_INT8_PTR KGCKeyIndex,
		FRM_INT8_PTR KGCstoreTag);
	/**
	* @brief    指令M3,导出主公钥(加密/签名)
	*
	* @param    KeyIndex				[in]    密钥索引号，1-64
	* @param    keyType				    [in]    密钥类型 1-3
	* @param    signPucKey   		    [out]   签名公钥，类型为1/3 时候存在
	* @param    EncryptPucKey    		[out]   加密公钥，类型为2/3 时候存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverM3_ExportPrimaryPubkey(
		FRM_INT8_PTR KeyIndex,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR* signPucKey,
		FRM_INT8_PTR* EncryptPucKey);
	/**
	* @brief    指令M4,密钥封装
	*
	* @param    KGCKeyIndexOrCipher	    [in]    KGC主公钥索引或KGC加密主公钥，9999时存在 0001-0064/9999
	* @param    ReceiverID			    [in]    接收方ID
	* @param    SessionKeyAlg	     	[in]    会话密钥算法 X/Y/P/R/L/M/N/Q
	* @param    keyEncapsulate  		[out]   密钥封装结构
	* @param    keyCipherByLmk		    [out]   会话密钥密文
	* @param    keyCheckValue    		[out]   会话密钥校验值
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverM4_KeyEncapsulate(
		FRM_INT8_PTR KGCKeyIndexOrCipher,
		FRM_INT8_PTR ReceiverID,
		FRM_INT8_PTR SessionKeyAlg,
		FRM_INT8_PTR* keyEncapsulate,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);

	/**
	* @brief    指令M5,密钥解封装
	*
	* @param    priKeyIndex		        [in]    用户私钥索引，0001-0256
	* @param    ReceiverID			    [in]    接收方ID
	* @param    keyEncapsulate  		[in]    密钥封装结构
	* @param    SessionKeyAlg	     	[in]    会话密钥算法  X/Y/P/R/L/M/N/Q
	* @param    keyCipherByLmk		    [out]   会话密钥密文
	* @param    keyCheckValue    		[out]   会话密钥校验值
	*
	* @return   成功返回0,否则返回非0
	*/

	FRM_INT32 STDCALL_ driverM5_KeyUnsealed(
		FRM_INT8_PTR priKeyIndex,
		FRM_INT8_PTR ReceiverID,
		FRM_INT8_PTR keyEncapsulate,
		FRM_INT8_PTR SessionKeyAlg,
		FRM_INT8_PTR* keyCipherByLmk,
		FRM_INT8_PTR* keyCheckValue);
	/**
	* @brief    指令M6,私钥签名
	*
	* @param    signpubKeyIndexOrCipher    [in]    KGC 签名主公钥索引或   (签名主公钥,当索引值为9999 时存在）
	* @param    userKeyIndex		       [in]    用户私钥索引，0001-0256
	* @param    data                       [in]    待签名数据
	* @param    signature		           [out]   签名数据
	*
	* @return   成功返回0,否则返回非0
	*/

	FRM_INT32 STDCALL_ driverM6_PrivateKeySign(
		FRM_INT8_PTR signpubKeyIndexOrCipher,
		FRM_INT8_PTR userKeyIndex,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* signature);
	/**
	* @brief    指令M7,公钥验签
	*
	* @param    signpubKeyIndexOrCipher [in]    KGC签名主公钥索引或 (签名主公钥,当索引值为9999 时存在）
	* @param    ID		                [in]    ID
	* @param    dataLen                 [in]    待签名数据长度
	* @param    data                    [in]    待签名数据
	* @param    signature		        [in]    签名数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverM7_PublicKeyAttesta(
		FRM_INT8_PTR signpubKeyIndexOrCipher,
		FRM_INT8_PTR ID,
		FRM_INT8_PTR data,
		FRM_INT8_PTR signature);
	/**
	* @brief    指令M8,公钥加密
	*
	* @param    keyType				    [in]    密钥类型 1-3
	* @param    encKeyIndexOrCipher     [in]    KGC加密主公钥索引或加密主公钥（当索引值为9999 时存在）
	* @param    ID		                [in]    ID
	* @param    data                    [in]    待加密数据
	* @param    cipher		            [in]    密文
	*
	* @return   成功返回0,否则返回非0
	*/

	FRM_INT32 STDCALL_ driverM8_PublicKeyEncrypt(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR encKeyIndexOrCipher,
		FRM_INT8_PTR ID,
		FRM_INT8_PTR data,
		FRM_INT8_PTR* cipher);

	/**
	* @brief    指令M9,私钥解密
	*
	* @param    keyType				    [in]    密钥类型 1-3
	* @param    KeyIndex		        [in]    用户私钥索引，0001-0256
	* @param    ID		                [in]    ID
	* @param    cipher		            [in]    密文，96-4192字节
	* @param    plain                   [out]   输出明文数据
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverM9_PrivateKeyDecrypt(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR KeyIndex,
		FRM_INT8_PTR ID,
		FRM_INT8_PTR cipher,
		FRM_INT8_PTR* plain);
	/**
	* @brief    指令MB,生成SM9用户密钥
	*
	* @param    keyType				    [in]    密钥类型 1-3
	* @param    KeyIndex		        [in]    系统主密钥索引，0001-0256
	* @param    UsreID		            [in]    用户ID
	* @param    priKeyStoreIndex		[in]    用户私钥存储索引，0001-0256
	* @param    pristoreTag      		[in]    标签,当索引不为9999 时存在
	* @param    signPriKey   		    [out]   签名私钥，类型为1/3 时候存在
	* @param    EncryptPriKey    		[out]   加密私钥，类型为2/3 时候存在
	*
	* @return   成功返回0,否则返回非0
	*/

	FRM_INT32 STDCALL_ driverMB_SM9GenerateUserKey(
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR KeyIndex,
		FRM_INT8_PTR UsreID,
		FRM_INT8_PTR priKeyStoreIndex,
		FRM_INT8_PTR pristoreTag,
		FRM_INT8_PTR* signPriKey,
		FRM_INT8_PTR* EncryptPriKey);

	/**
	* @brief    指令ME,保护导出用户私钥
	*
	* @param    algorithmMode               [in]    加密时的运算模式,限00/01
	* @param    protectKeyType              [in]    保护密钥类型,限000/011/109或ZMK(KEK)/KMC/MDK
	* @param    protectKeyIndexOrCipher     [in]    保护密钥索引或LMK加密的密文
	* @param    protectKeyDiversifyFactor   [in]    保护密钥分散因子,每级16字节,最多3级
	* @param    sessionKeyGenMode           [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor            [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    iv                          [in]    初始向量,algorithmMode为CBC/01时有效
	* @param    exportedKeyIndex            [in]    被保护密钥索引
	* @param    ID							[in]    ID
	* @param    keyType						[in]    密钥类型 1-3
	* @param    UserSignPriKey   			[in]    签名私钥，索引9999 时有效
	* @param    UserEncryptPriKey    		[in]    加密私钥，索引9999 时有效
	* @param    signPriKey   				[out]   签名私钥，类型为1/3 时候存在
	* @param    EncryptPriKey    			[out]   加密私钥，类型为2/3 时候存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverME_ProtectExportUserPrikey(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR protectKeyType,
		FRM_INT8_PTR protectKeyIndexOrCipher,
		FRM_INT8_PTR protectKeyDiversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR exportedKeyIndex,
		FRM_INT8_PTR ID,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR UserSignPriKey,
		FRM_INT8_PTR UserEncryptPriKey,
		FRM_INT8_PTR* signPriKey,
		FRM_INT8_PTR* EncryptPriKey);
	/**
	* @brief    指令MF,保护导入用户私钥
	*
	* @param    algorithmMode               [in]    加密时的运算模式,限00/01
	* @param    protectKeyType              [in]    保护密钥类型,限000/011/109或ZMK(KEK)/KMC/MDK
	* @param    protectKeyIndexOrCipher     [in]    保护密钥索引或LMK加密的密文
	* @param    protectKeyDiversifyFactor   [in]    保护密钥分散因子,每级16字节,最多3级
	* @param    sessionKeyGenMode           [in]    会话密钥产生模式,00-05
	* @param    sessionKeyFactor            [in]    会话密钥因子,当sessionKeyGenMode值为01/02/05时有效,01时8字节,02/05时16字节
	* @param    iv                          [in]    初始向量,algorithmMode为CBC/01时有效
	* @param    keyType						[in]    密钥类型 1-3
	* @param    priKeyStoreIndex		    [in]    用户私钥存储索引，0001-0256
	* @param    pristoreTag      		    [in]    标签,当索引不为9999 时存在
	* @param    ID							[in]    ID
	* @param    SignPriKey   				[in]    签名私钥
	* @param    EncryptPriKey    			[in]    加密私钥
	* @param    UserSignPriKey   			[out]    用户签名私钥，类型为1/3 时候存在
	* @param    UserEncryptPriKey    		[out]    用户加密私钥，类型为1/3 时候存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverMF_ProtectImportUserPrikey(
		FRM_INT8_PTR algorithmMode,
		FRM_INT8_PTR protectKeyType,
		FRM_INT8_PTR protectKeyIndexOrCipher,
		FRM_INT8_PTR protectKeyDiversifyFactor,
		FRM_INT8_PTR sessionKeyGenMode,
		FRM_INT8_PTR sessionKeyFactor,
		FRM_INT8_PTR iv,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR priKeyStoreIndex,
		FRM_INT8_PTR pristoreTag,
		FRM_INT8_PTR ID,
		FRM_INT8_PTR signPriKey,
		FRM_INT8_PTR EncryptPriKey,
		FRM_INT8_PTR* UserSignPriKey,
		FRM_INT8_PTR* UserEncryptPriKey);
	/**
	* @brief    指令MG,导出用户密钥
	*
	* @param    KeyIndex					[in]    密钥索引号，1-64
	* @param    keyType				    	[in]    密钥类型 1-3
	* @param    UserSignPriKey   			[out]   用户签名私钥，类型为1/3 时候存在
	* @param    UserEncryptPriKey    		[out]   用户加密私钥，类型为1/3 时候存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverMG_ExportUserKey(
		FRM_INT8_PTR KeyIndex,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR* UserSignPriKey,
		FRM_INT8_PTR* UserEncryptPriKey);
	/**
	* @brief    指令MH,导出KGC主公钥
	*
	* @param    KeyIndex					[in]    密钥索引号，1-64
	* @param    keyType				    	[in]    密钥类型 1-3
	* @param    KgcSignPriKey   			[out]   KGC签名私钥，类型为1/3 时候存在
	* @param    KgcEncryptPriKey    		[out]   KGC加密私钥，类型为1/3 时候存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driverMH_ExportKGCPubkey(
		FRM_INT8_PTR KeyIndex,
		FRM_INT8_PTR keyType,
		FRM_INT8_PTR* KgcSignPriKey,
		FRM_INT8_PTR* KgcEncryptPriKey);
	/**
	* @brief    导入私钥明文
	*
	* @param    priKeyPlain					[in]    私钥明文
	* @param    index						[in]    加密机存储索引
	* @param    publicKeyDer				[in]    der编码公钥
	* @param    TagsdataOut					[out]   Tag数据计算后的认证值,仅加密时存在
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ ImportPriKeyPlain(
		FRM_INT8_PTR priKeyPlain,
		FRM_INT8_PTR index,
		FRM_INT8_PTR publicKeyDer);

    /**
	* @brief   命令代码0664 产生PINOFFSET
	*
	* @param    srcZpkIndexOrCipher		    [in]    用于加密PIN的ZPK密钥索引或密文
	* @param    srcPinBlockFormat			[in]    源字符PINBLOCK格式,标识使用ZPK加密PIN时的PIN数据块组成格式,
	*                                               详细参见PINBLOCK(字符)格式
	* @param    srcAccountNum				[in]    参与源ZPK密钥对PINBLOCK加密运算的帐号
	* @param    pinBlockCipherBySrcZpk		[in]    ZPK加密的PIN Block
	* @param    pvkIndexOrCipherByLmk		[in]    PVK密钥索引或LMK下加密的PVK密文,用于产生OFFSET
	* @param    pinVerifyLen         		[in]    最小的PIN校验长度
	* @param    desPan              		[in]    目的账号,用户主账号有效位的最右12个数字
	* @param    decConverTable              [in]    十进制转换表,转换16进制到10进制数的表
	* @param    pinVerifyData          		[in]    PIN校验数据，用户定义的数据，包含11个16 进制字符和1个字符N(向密码机指出在哪里插入帐号的最后5位）
	* @param    CompatibilityMode      		[in]    可选域(默认使用标准模式)
    *                                               0 - 标准模式计算PINOFFET
    *                                               1 - 兼容科友算法计算PINOFFSET
	* @param    pinOffset					[out]   pinoffset
	*
	* @return   成功返回0,否则返回非0
	*/
	FRM_INT32 STDCALL_ driver0664_GenePINOffset(
		FRM_INT8_PTR srcZpkIndexOrCipher,
		FRM_INT8_PTR srcPinBlockFormat,
		FRM_INT8_PTR srcAccountNum,
		FRM_INT8_PTR pinBlockCipherBySrcZpk,
		FRM_INT8_PTR pvkIndexOrCipherByLmk,
		FRM_INT8_PTR pinVerifyLen,
		FRM_INT8_PTR desPan,
		FRM_INT8_PTR decConverTable,
		FRM_INT8_PTR pinVerifyData,
		FRM_INT8_PTR CompatibilityMode,
		FRM_INT8_PTR* pinOffset);

#ifdef  __cplusplus
}
#endif
#endif
